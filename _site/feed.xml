<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-02-26T20:21:46+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Darryl’s Pixels</title><subtitle>Blog about code and stuff...</subtitle><author><name>Darryl Gouder</name></author><entry><title type="html">Measuring the Rendering Equation</title><link href="http://localhost:4000/mathematics,/rendering,/graphics/2028/08/15/radiometry_rend_eq/" rel="alternate" type="text/html" title="Measuring the Rendering Equation" /><published>2028-08-15T00:30:00+01:00</published><updated>2028-08-15T00:30:00+01:00</updated><id>http://localhost:4000/mathematics,/rendering,/graphics/2028/08/15/radiometry_rend_eq</id><content type="html" xml:base="http://localhost:4000/mathematics,/rendering,/graphics/2028/08/15/radiometry_rend_eq/">&lt;p&gt;The root concept of all computer graphics is the propogation light, and how we describe and measure its propogration throughout a scene. In the case of physically based rendering, physics is our ground truth, therefore the quantities used to measure light and the ideas on how the light behaves under arbitrary conditions are an attractive and elegant way of simulating light transport. At the root all these physical ideas is radiometry.&lt;/p&gt;

&lt;p&gt;This is a topic that I initially did not hold as much appreciation as I should have when I first started out in computer graphics, however I’ve come to realize that understanding radiometry well will lead to a more intuitive understanding of many different concepts in PBR. In this blog post, I’ll use various sources to write at length about the different radiometric quantities, with examples and as many visual cues as possible.&lt;/p&gt;

&lt;p&gt;Light is the visible part of the electromagnetic spectrum and therefor subject to all the ideas that we have regarding the behaviour of electromagnetic radiation. Most of us are familiar with the speed of light, approximately measured at 299,792,458 metres per second in a vacuum. This value is a commonly referred to as c and is part of a special group known as universal constants - a value which is constant both in the universe and in time.&lt;/p&gt;

&lt;p&gt;Light carries some form of energy, the unit of which we measure in Joules. We refer to this energy as radiant energy. The function that measures the amount of energy generated is in terms of the wavelength of the light. (write equation) states that the energy carried by a photon (which we can consider as 1 unit of light) is equal to the speed of light multiplied by Planck’s constant, divided by the wavelength. Planck’s constant is another one of these universal constants. (Talk a bit about Planck’s constant).&lt;/p&gt;

&lt;p&gt;Although energy is transmitted over an amount of time, when we’e rendering, we’re measuring light at one point at a time - and to do so we need to take the differential energy per differential time, the resulting units being joules per second. This value is known as radiant flux, or power. It is the total amount of energy passing through a surface or region of space per unit time.&lt;/p&gt;

&lt;p&gt;Now that we have radiant flux, we need to measure how much flux is arriving at or leaving a particular surface area, per 1 unit of time. This value is known as irradiance, if the area is receiving light, or radiant exitance if it is leaving it. The measurements of this will be W/m^2, we’re taking the differential power per differential area at a point.&lt;/p&gt;

&lt;p&gt;Before we measure radiance, we need to define the idea of a solid angle. We are accustomed to the idea of measuring angles about a point, in 2D, where a full revolution of 360 degrees results in a circle. An extension of this, whereby we define an angle with respect to a plane, results in a sphere covering all the possible angles about a point. We measure planar angles in radians - and the spherical angles in steradians, which is the total area subtended by the object projected on the unit sphere surrounding the point.&lt;/p&gt;

&lt;p&gt;Radiance is the most important radiometric quantity. Whereas irradiance and radiant exitance gave us the differential power per differential area at a point p, the direction was not at all specified.&lt;/p&gt;

&lt;p&gt;In this post we’ll re-visit radiometry. I’ve been re-reading the radiometry chapters from Advanced Global Illumination and PBRT. And I had an 11 hour flight which I felt was the appropriate time to dive into the Veach thesis. For those unfamiliar with the Veach thesis, it’s Eric Veach’s PhD thesis titled Robust Monte Carlo Methods for Light Transport Simulation. It introduces the ideas of Multiple Importance Sampling, Bidirectional Path Tracing and Metropolis Light Transport, and is a must read for anyone interested in rendering and light transport. Dr. Veach does an excellent job of building up the foundational knowledge required to understamd thsese concepts.&lt;/p&gt;

&lt;p&gt;I’ll talk a bit about the radiometric quantities and borrow from many different sources to explain and visualize as best I can each one.&lt;/p&gt;

&lt;p&gt;LOOK AT THE 2D GLOBAL ILLUMINATION PAPER BY JAROSZ.&lt;/p&gt;

&lt;p&gt;The first quantity I’ll describe is the radiant power which is the energy per unit time, measured in watts (joules per second). For example, it’s used to describe how much energy is emitted by some light source. With Q(t) being the function that measures the photonic energy in an area D(t), the function to describe the rate of energy would be the differentiated function of this - dQ(t) / dt  The mathematical notation for the radiant power. In most cases however, we don’t really worry about the energy changing over time, so we can usually leave out this parameter in our notation.&lt;/p&gt;

&lt;p&gt;Irradiance is defined as the power per unit surface area, which would be Watts per meters squared. The irradiance is defined with respect to a point on a surface. The point is our unit surface area. The irradiance is ususally specific to the INCIDENT power per unit surface - if the light is leaving the surface then it is usually referred to as radiant exitance.&lt;/p&gt;

&lt;p&gt;Radiance is is the ratio&lt;/p&gt;

&lt;p&gt;The beast that is the rendering equation attempts to measure the outputted light from a single point. The most common from most people are familiar with is the one below:&lt;/p&gt;

&lt;p&gt;L(x, w_o) is attempting to measure the light outgoing from point x. Light outgoing, however, is a very ambiguous term. I’ll attempt to explain some of the units related to the measuring of light and immediately tie them to the rendering equation.&lt;/p&gt;</content><author><name>Darryl Gouder</name></author><summary type="html">The root concept of all computer graphics is the propogation light, and how we describe and measure its propogration throughout a scene. In the case of physically based rendering, physics is our ground truth, therefore the quantities used to measure light and the ideas on how the light behaves under arbitrary conditions are an attractive and elegant way of simulating light transport. At the root all these physical ideas is radiometry. This is a topic that I initially did not hold as much appreciation as I should have when I first started out in computer graphics, however I’ve come to realize that understanding radiometry well will lead to a more intuitive understanding of many different concepts in PBR. In this blog post, I’ll use various sources to write at length about the different radiometric quantities, with examples and as many visual cues as possible. Light is the visible part of the electromagnetic spectrum and therefor subject to all the ideas that we have regarding the behaviour of electromagnetic radiation. Most of us are familiar with the speed of light, approximately measured at 299,792,458 metres per second in a vacuum. This value is a commonly referred to as c and is part of a special group known as universal constants - a value which is constant both in the universe and in time. Light carries some form of energy, the unit of which we measure in Joules. We refer to this energy as radiant energy. The function that measures the amount of energy generated is in terms of the wavelength of the light. (write equation) states that the energy carried by a photon (which we can consider as 1 unit of light) is equal to the speed of light multiplied by Planck’s constant, divided by the wavelength. Planck’s constant is another one of these universal constants. (Talk a bit about Planck’s constant). Although energy is transmitted over an amount of time, when we’e rendering, we’re measuring light at one point at a time - and to do so we need to take the differential energy per differential time, the resulting units being joules per second. This value is known as radiant flux, or power. It is the total amount of energy passing through a surface or region of space per unit time. Now that we have radiant flux, we need to measure how much flux is arriving at or leaving a particular surface area, per 1 unit of time. This value is known as irradiance, if the area is receiving light, or radiant exitance if it is leaving it. The measurements of this will be W/m^2, we’re taking the differential power per differential area at a point. Before we measure radiance, we need to define the idea of a solid angle. We are accustomed to the idea of measuring angles about a point, in 2D, where a full revolution of 360 degrees results in a circle. An extension of this, whereby we define an angle with respect to a plane, results in a sphere covering all the possible angles about a point. We measure planar angles in radians - and the spherical angles in steradians, which is the total area subtended by the object projected on the unit sphere surrounding the point. Radiance is the most important radiometric quantity. Whereas irradiance and radiant exitance gave us the differential power per differential area at a point p, the direction was not at all specified. In this post we’ll re-visit radiometry. I’ve been re-reading the radiometry chapters from Advanced Global Illumination and PBRT. And I had an 11 hour flight which I felt was the appropriate time to dive into the Veach thesis. For those unfamiliar with the Veach thesis, it’s Eric Veach’s PhD thesis titled Robust Monte Carlo Methods for Light Transport Simulation. It introduces the ideas of Multiple Importance Sampling, Bidirectional Path Tracing and Metropolis Light Transport, and is a must read for anyone interested in rendering and light transport. Dr. Veach does an excellent job of building up the foundational knowledge required to understamd thsese concepts. I’ll talk a bit about the radiometric quantities and borrow from many different sources to explain and visualize as best I can each one. LOOK AT THE 2D GLOBAL ILLUMINATION PAPER BY JAROSZ.</summary></entry><entry><title type="html">Ray Tracing The Rest of Your Life: A reader’s companion, Chapter 3 and 4</title><link href="http://localhost:4000/rendering/2019/02/27/rt_rc_chapter3_4/" rel="alternate" type="text/html" title="Ray Tracing The Rest of Your Life: A reader's companion, Chapter 3 and 4" /><published>2019-02-27T10:30:00+00:00</published><updated>2019-02-27T10:30:00+00:00</updated><id>http://localhost:4000/rendering/2019/02/27/rt_rc_chapter3_4</id><content type="html" xml:base="http://localhost:4000/rendering/2019/02/27/rt_rc_chapter3_4/">&lt;p&gt;Welcome back! If you’re joining from the 2nd post, you can skip ahead and start reading from the Chapter 3 title. If not, here’s a &lt;a href=&quot;https://dargouder.github.io/darryls-pixels/rendering/2019/01/04/rt_rc_chapter1/&quot; target=&quot;_blank&quot;&gt;link&lt;/a&gt; to the first post as there’s some information in the beginning about this blog series.&lt;/p&gt;

&lt;h1 id=&quot;chapter-3-mc-integration-on-the-sphere-of-directions&quot;&gt;Chapter 3: MC Integration on the Sphere of Directions&lt;/h1&gt;

&lt;h1 id=&quot;chapter-4-light-scattering&quot;&gt;Chapter 4: Light Scattering&lt;/h1&gt;

&lt;h1 id=&quot;chapter-5-importance-sampling-materials&quot;&gt;Chapter 5 Importance Sampling Materials&lt;/h1&gt;

&lt;p&gt;Monte Carlo is widely used to solve integrals of higher dimensions, where an analytical method is not possible, or other integral computational methods are intractable. Dr. Shirley selects a simple integral to show how effective Monte Carlo integration is.&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;color:red;&quot;&gt;
&lt;b&gt;
Start reading the chapter right until you get to the code that computes the integral. Don’t worry if you don’t get it, I’m going to explain everything.
&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;The integral is &lt;script type=&quot;math/tex&quot;&gt;\int_0^2 x^2 dx&lt;/script&gt; which will compute the area under the curve, with the limits 0 to 2. So how do we translate this into a Monte Carlo estimate? I was a bit confused by the sudden appearance of the 2 being multiplied with the average(x^2, 0, 2) function. Why are we multiplying the sample average by 2? Well as it turns out, this how we perform Monte Carlo integration. A generic integral of the form:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F = \int_a^b f(x)&lt;/script&gt;

&lt;p&gt;can be estimated with a Monte Carlo estimator by performing&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(b-a) \frac{1}{N} \sum_{i=0}^{N-1} f(X_i)&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;x_i&lt;/script&gt; are uniformly distributed random numbers between 0 and 1, and &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; is the number of samples you pick.&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;color:red;&quot;&gt;
&lt;b&gt;
Read the book right up until he proposes making his own PDF. I’ll lengthen the explanation and drive in a bit of probability, enough to show you the ropes but not enough to bore you (hopefully).
&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;I think a short introduction into probability theory with a bit more formality will go a long way into helping you understand what Dr. Shirley computes in the book and other future graphics problems.&lt;/p&gt;

&lt;p&gt;We’ve been talking about random variables for a while. We know that generating a uniform random variable means that we use a function to generate a number in a particular range and since we stipulated that it is uniform, this also means that any other number in that range could have been picked with the exact same probability.&lt;/p&gt;

&lt;p&gt;We’ll introduce some terms.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; represents the random variable. Since we’re using random variables to estimate something, this also is referred to as a random variable!&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;P(X)&lt;/script&gt; represents the probability of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;P(X = x)&lt;/script&gt; represents the probability that &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is a particular value &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To exemplify these terms, in our statistical experiment we are going to toss a coin twice.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is the number of heads that we get.  This is the random variable that is the result of our 2 coin tosses. &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; will either be 0 (&lt;script type=&quot;math/tex&quot;&gt;TT&lt;/script&gt;), 1(&lt;script type=&quot;math/tex&quot;&gt;HT&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;TH&lt;/script&gt;) or 2(&lt;script type=&quot;math/tex&quot;&gt;HH&lt;/script&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;P(X)&lt;/script&gt; will be the probability of getting 0, 1 or 2 heads.&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;P(X = x)&lt;/script&gt; will be a particular sequence of coin tosses, such as &lt;script type=&quot;math/tex&quot;&gt;TT&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;TH&lt;/script&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The cumulative distribution function (CDF) and the probability mass/density function (pmf/PDF) are the 2 pillars of understanding the nature of a random variable. The reason I used mass/density is because mass is used when we are describing a discrete distribution, and density is used in the continuous case. In this example, it’s the pmf (a coin toss is a discrete experiment) that I’ll be talking about, however the same ideas hold for the PDF.&lt;/p&gt;

&lt;p&gt;This is the CDF of the experiment above:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;P(X)&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;CDF &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
P(X &lt;=x) %]]&gt;&lt;/script&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0.25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0.75&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;As you may have noticed, the CDF is maxed out at one. 1 is the upper limit of the probability that an event from an experiment occurs - 0 is the lower limit. It is called cumulative because the probability distribution accumulates with each event. If you haven’t understood what that table is representing, let’s use our words!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;P(X=0)&lt;/script&gt; means that that probability of getting no heads is 0.25.&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
P(X&lt;=1) %]]&gt;&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;&lt;/script&gt;P(X=1) + P(X=0)&lt;script type=&quot;math/tex&quot;&gt;&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;P(X=1)&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;TH&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;HT&lt;/script&gt; and therefore we’re adding 0.5 to the probability of getting &lt;script type=&quot;math/tex&quot;&gt;TT&lt;/script&gt; which is 0.25, hence 0.75.&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
P(X&lt;=2) %]]&gt;&lt;/script&gt; is just the probability of &lt;script type=&quot;math/tex&quot;&gt;HH&lt;/script&gt; (0.25) + the previous 0.75, our final result being 1.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is what the CDF looks like when we plot it&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/posts/rt_rc_chapter2/coin_toss_cdf.png&quot; alt=&quot;CDF of 2 coin tosses &quot; /&gt;
&lt;/p&gt;

&lt;p&gt;So can you guess what the PMF will look like? Hint: the pmf will describe the probability of each occurring coin toss .&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;P(X)&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;PMF &lt;script type=&quot;math/tex&quot;&gt;P(X =x)&lt;/script&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0 heads&lt;/td&gt;
      &lt;td&gt;0.25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1 heads&lt;/td&gt;
      &lt;td&gt;0.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2 heads&lt;/td&gt;
      &lt;td&gt;0.25&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If you sum up all the probabilities, they’ll add up to 1. So the PMF is showing us the probability of an event occurrence and CDF is showing us the probability of a range of events occuring. I know I keep on repeating this statement, but it’s common to not fully grasp the difference between the CDF and PMF and be unsure of their purpose. If you look hard at both, see you can go from the CDF to the PMF and vice versa.&lt;/p&gt;

&lt;p&gt;So what happens if we’re dealing with continuous cases?
Well for starters, the PMF changes to a PDF. We are also usually presented with functions to represent the CDF and PDF. To find the CDF from the PDF, we integrate the PDF from &lt;script type=&quot;math/tex&quot;&gt;-\infty&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is a placeholder variable.&lt;/p&gt;

&lt;p&gt;I’m not going to show an example because at this point I think you should go back to the book but wait until this final concept.&lt;/p&gt;

&lt;p&gt;We’ve mentioned that we have been generating uniform random variables using a PRNG. In many cases however, we would like to take these uniform random numbers and would like to make them follow some other kind of distribution. We want to &lt;em&gt;transform&lt;/em&gt; them. The way to go about this is a technique known as the Inverse Transform method. The technique is very simple and very powerful:
 Let’s say we have a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; , that has a CDF &lt;script type=&quot;math/tex&quot;&gt;F(X)&lt;/script&gt;. We want to generate values distributed according to this distribution. The steps to do this are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Generate a uniform random number u between &lt;script type=&quot;math/tex&quot;&gt;[0,1]&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;Find the inverse of the CDF of &lt;script type=&quot;math/tex&quot;&gt;F(X)&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;We find X by computing &lt;script type=&quot;math/tex&quot;&gt;F^{-1}(u)&lt;/script&gt;.  &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is now distributed according to &lt;script type=&quot;math/tex&quot;&gt;F(X)&lt;/script&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The Inverse Transform method warrants its own blog post so I won’t go into detail about its intrinsics and its edge cases and so forth.&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;color:red;&quot;&gt;
&lt;b&gt;
	Go back to the book and come back right after you’ve obtained the inverse of the CDF. 
&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;We have computed a Monte Carlo estimation of an integral, and now we’ve computed the inverse cdf of a PDF, which means we can transform our uniform random numbers into the PDF that we selected. If you recall, we said that we draw our samples from a uniform distribution from 1 to 0 in our original definition of the Monte Carlo estimator. The PDF of this estimator is &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{1-0}&lt;/script&gt; which is &lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;. The more general Monte Carlo estimator definition is actually this:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{1}{N} \sum_{i=0}^{N-1} \frac{f(X_i)}{p(X_i)}&lt;/script&gt;

&lt;p&gt;Where &lt;script type=&quot;math/tex&quot;&gt;p(X_i)&lt;/script&gt; is the PDF from which the samples are drawn. By selecting a PDF that matches the shape of the function that we are trying to estimate, we are weighting the samples so as to reduce the variance. This is known as Importance Sampling! Choosing a good PDF is an ongoing form of research. For our integral, the PDF Dr Shirley’s picked is &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{r}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;For the moment, we’ve been drawing samples from the uniform distribution, but thanks to the inverse transform method, we’re now using these uniform numbers and transforming them to match the new PDF. We’ll then compute our original integral with these new random variables and divide by the new PDF.&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;color:red;&quot;&gt;
&lt;b&gt;
Now would be a good time to finish the chapter.
&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;I don’t really have much to add to that. If you feel more mathematically inclined, I would suggest you have a look at &lt;a href=&quot;http://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration.html&quot; target=&quot;_blank&quot;&gt;PBRT Chapter 13 &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you have any questions and feedback, feel free to comment or contact me via twitter/email.&lt;/p&gt;</content><author><name>Darryl Gouder</name></author><summary type="html">Welcome back! If you’re joining from the 2nd post, you can skip ahead and start reading from the Chapter 3 title. If not, here’s a link to the first post as there’s some information in the beginning about this blog series. Chapter 3: MC Integration on the Sphere of Directions Chapter 4: Light Scattering Chapter 5 Importance Sampling Materials Monte Carlo is widely used to solve integrals of higher dimensions, where an analytical method is not possible, or other integral computational methods are intractable. Dr. Shirley selects a simple integral to show how effective Monte Carlo integration is. Start reading the chapter right until you get to the code that computes the integral. Don’t worry if you don’t get it, I’m going to explain everything. The integral is which will compute the area under the curve, with the limits 0 to 2. So how do we translate this into a Monte Carlo estimate? I was a bit confused by the sudden appearance of the 2 being multiplied with the average(x^2, 0, 2) function. Why are we multiplying the sample average by 2? Well as it turns out, this how we perform Monte Carlo integration. A generic integral of the form: can be estimated with a Monte Carlo estimator by performing</summary></entry><entry><title type="html">Ray Tracing The Rest of Your Life: A reader’s companion, Chapter 2</title><link href="http://localhost:4000/rendering/2019/02/21/rt_rc_chapter2/" rel="alternate" type="text/html" title="Ray Tracing The Rest of Your Life: A reader's companion, Chapter 2" /><published>2019-02-21T00:00:00+00:00</published><updated>2019-02-21T00:00:00+00:00</updated><id>http://localhost:4000/rendering/2019/02/21/rt_rc_chapter2</id><content type="html" xml:base="http://localhost:4000/rendering/2019/02/21/rt_rc_chapter2/">&lt;p&gt;Welcome back! If you’re joining from the 1st post, you can skip ahead and start reading from the Chapter 2 title. If not, here’s a &lt;a href=&quot;https://dargouder.github.io/darryls-pixels/rendering/2019/02/15/rt_rc_chapter1/&quot; target=&quot;_blank&quot;&gt;link&lt;/a&gt; to the first post as there’s some information in the beginning about this blog series.&lt;/p&gt;

&lt;h1 id=&quot;chapter-2-one-dimensional-mc-integration&quot;&gt;Chapter 2: One Dimensional MC Integration&lt;/h1&gt;

&lt;p&gt;Monte Carlo is widely used to solve integrals of higher dimensions, where an analytical method is not possible, or other integral computational methods are intractable. Dr. Shirley selects a simple integral to show how effective Monte Carlo integration is.&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;color:red;&quot;&gt;
&lt;b&gt;
Start reading the chapter right until you get to the code that computes the integral. Don’t worry if you don’t get it, I’m going to explain everything.
&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;The integral is &lt;script type=&quot;math/tex&quot;&gt;\int_0^2 x^2 dx&lt;/script&gt; which will compute the area under the curve, with the limits 0 to 2. So how do we translate this into a Monte Carlo estimate? I was a bit confused by the sudden appearance of the 2 being multiplied with the average(x^2, 0, 2) function. Why are we multiplying the sample average by 2? Well as it turns out, this how we perform Monte Carlo integration. A generic integral of the form:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F = \int_a^b f(x)&lt;/script&gt;

&lt;p&gt;can be estimated with a Monte Carlo estimator by performing&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(b-a) \frac{1}{N} \sum_{i=0}^{N-1} f(X_i)&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;x_i&lt;/script&gt; are uniformly distributed random numbers between 0 and 1, and &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; is the number of samples you pick.&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;color:red;&quot;&gt;
&lt;b&gt;
Read the book right up until he proposes making his own PDF. I’ll lengthen the explanation and drive in a bit of probability, enough to show you the ropes but not enough to bore you (hopefully).
&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;So the area function Dr. Shirley is trying to calculate is:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_0^2 C' r dr = \frac{1}{2} [C'r^2]_0^2 = 2C'
\\
1 = 2C'
\\
C' = \frac{1}{2}&lt;/script&gt;

&lt;p&gt;Knowing that &lt;script type=&quot;math/tex&quot;&gt;p(r) = C'r&lt;/script&gt; this leads to &lt;script type=&quot;math/tex&quot;&gt;p(r) = \frac{r}{2}&lt;/script&gt;. The rest is pretty readable and understandable so I’ll move onto something else.&lt;/p&gt;

&lt;p&gt;A short introduction into probability theory with a bit more formality will go a long way into helping you understand what Dr. Shirley computes in the book and other future graphics problems.&lt;/p&gt;

&lt;p&gt;We’ve been talking about random variables for a while. We know that generating a uniform random variable means that we use a function to generate a number in a particular range and since we stipulated that it is uniform, this also means that any other number in that range could have been picked with the exact same probability.&lt;/p&gt;

&lt;p&gt;We’ll introduce some terms.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; represents the random variable. Since we’re using random variables to estimate something, this also is referred to as a random variable!&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;P(X)&lt;/script&gt; represents the probability of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;P(X = x)&lt;/script&gt; represents the probability that &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is a particular value &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To exemplify these terms, in our statistical experiment we are going to toss a coin twice.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is the number of heads that we get.  This is the random variable that is the result of our 2 coin tosses. &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; will either be 0 (&lt;script type=&quot;math/tex&quot;&gt;TT&lt;/script&gt;), 1(&lt;script type=&quot;math/tex&quot;&gt;HT&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;TH&lt;/script&gt;) or 2(&lt;script type=&quot;math/tex&quot;&gt;HH&lt;/script&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;P(X)&lt;/script&gt; will be the probability of getting 0, 1 or 2 heads.&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;P(X = x)&lt;/script&gt; will be a particular sequence of coin tosses, such as &lt;script type=&quot;math/tex&quot;&gt;TT&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;TH&lt;/script&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The cumulative distribution function (CDF) and the probability mass/density function (pmf/PDF) are the 2 pillars of understanding the nature of a random variable. The reason I used mass/density is because mass is used when we are describing a discrete distribution, and density is used in the continuous case. In this example, it’s the pmf (a coin toss is a discrete experiment) that I’ll be talking about, however the same ideas hold for the PDF.&lt;/p&gt;

&lt;p&gt;This is the CDF of the experiment above:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;P(X)&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;CDF &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
P(X &lt;=x) %]]&gt;&lt;/script&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0.25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0.75&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;As you may have noticed, the CDF is maxed out at one. 1 is the upper limit of the probability that an event from an experiment occurs - 0 is the lower limit. It is called cumulative because the probability distribution accumulates with each event. If you haven’t understood what that table is representing, let’s use our words!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;P(X=0)&lt;/script&gt; means that that probability of getting no heads is 0.25.&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
P(X&lt;=1) %]]&gt;&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;&lt;/script&gt;P(X=1) + P(X=0)&lt;script type=&quot;math/tex&quot;&gt;&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;P(X=1)&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;TH&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;HT&lt;/script&gt; and therefore we’re adding 0.5 to the probability of getting &lt;script type=&quot;math/tex&quot;&gt;TT&lt;/script&gt; which is 0.25, hence 0.75.&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
P(X&lt;=2) %]]&gt;&lt;/script&gt; is just the probability of &lt;script type=&quot;math/tex&quot;&gt;HH&lt;/script&gt; (0.25) + the previous 0.75, our final result being 1.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is what the CDF looks like when we plot it&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/posts/rt_rc_chapter2/coin_toss_cdf.png&quot; alt=&quot;CDF of 2 coin tosses &quot; /&gt;
&lt;/p&gt;

&lt;p&gt;So can you guess what the PMF will look like? Hint: the pmf will describe the probability of each occurring coin toss .&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;P(X)&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;PMF &lt;script type=&quot;math/tex&quot;&gt;P(X =x)&lt;/script&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0 heads&lt;/td&gt;
      &lt;td&gt;0.25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1 heads&lt;/td&gt;
      &lt;td&gt;0.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2 heads&lt;/td&gt;
      &lt;td&gt;0.25&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If you sum up all the probabilities, they’ll add up to 1. So the PMF is showing us the probability of an event occurrence and CDF is showing us the probability of a range of events occuring. I know I keep on repeating this statement, but it’s common to not fully grasp the difference between the CDF and PMF and be unsure of their purpose. If you look hard at both, see you can go from the CDF to the PMF and vice versa.&lt;/p&gt;

&lt;p&gt;So what happens if we’re dealing with continuous cases?
Well for starters, the PMF changes to a PDF. We are also usually presented with functions to represent the CDF and PDF. To find the CDF from the PDF, we integrate the PDF from &lt;script type=&quot;math/tex&quot;&gt;-\infty&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is a placeholder variable.&lt;/p&gt;

&lt;p&gt;I’m not going to show an example because at this point I think you should go back to the book but wait until this final concept.&lt;/p&gt;

&lt;p&gt;We’ve mentioned that we have been generating uniform random variables using a PRNG. In many cases however, we would like to take these uniform random numbers and would like to make them follow some other kind of distribution. We want to &lt;em&gt;transform&lt;/em&gt; them. The way to go about this is a technique known as the Inverse Transform method. The technique is very simple and very powerful:
 Let’s say we have a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; , that has a CDF &lt;script type=&quot;math/tex&quot;&gt;F(X)&lt;/script&gt;. We want to generate values distributed according to this distribution. The steps to do this are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Generate a uniform random number u between &lt;script type=&quot;math/tex&quot;&gt;[0,1]&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;Find the inverse of the CDF of &lt;script type=&quot;math/tex&quot;&gt;F(X)&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;We find X by computing &lt;script type=&quot;math/tex&quot;&gt;F^{-1}(u)&lt;/script&gt;.  &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is now distributed according to &lt;script type=&quot;math/tex&quot;&gt;F(X)&lt;/script&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The Inverse Transform method warrants its own blog post so I won’t go into detail about its intrinsics and its edge cases and so forth.&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;color:red;&quot;&gt;
&lt;b&gt;
	Go back to the book and come back right after you’ve obtained the inverse of the CDF. 
&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;We have computed a Monte Carlo estimation of an integral, and now we’ve computed the inverse cdf of a PDF, which means we can transform our uniform random numbers into the PDF that we selected. If you recall, we said that we draw our samples from a uniform distribution from 1 to 0 in our original definition of the Monte Carlo estimator. The PDF of this estimator is &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{1-0}&lt;/script&gt; which is &lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;. The more general Monte Carlo estimator definition is actually this:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{1}{N} \sum_{i=0}^{N-1} \frac{f(X_i)}{p(X_i)}&lt;/script&gt;

&lt;p&gt;Where &lt;script type=&quot;math/tex&quot;&gt;p(X_i)&lt;/script&gt; is the PDF from which the samples are drawn. By selecting a PDF that matches the shape of the function that we are trying to estimate, we are weighting the samples so as to reduce the variance. This is known as Importance Sampling! Choosing a good PDF is an ongoing form of research. For our integral, the PDF Dr Shirley’s picked is &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{r}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;For the moment, we’ve been drawing samples from the uniform distribution, but thanks to the inverse transform method, we’re now using these uniform numbers and transforming them to match the new PDF. We’ll then compute our original integral with these new random variables and divide by the new PDF.&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;color:red;&quot;&gt;
&lt;b&gt;
Now would be a good time to finish the chapter.
&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;If you feel more mathematically inclined, &lt;a href=&quot;https://twitter.com/Atrix256&quot; target=&quot;_blank&quot;&gt;Alan Wolfe&lt;/a&gt; has a great &lt;a href=&quot;https://blog.demofox.org/2018/06/12/monte-carlo-integration-explanation-in-1d/&quot; target=&quot;_blank&quot;&gt;blog post about One-Dimensional Monte Carlo Integration&lt;/a&gt;. He’s also got a plethora of posts that will have some common content with this blog post series. I would also suggest you have a look at &lt;a href=&quot;http://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration.html&quot; target=&quot;_blank&quot;&gt;PBRT Chapter 13 &lt;/a&gt; if you’re feeling brave!&lt;/p&gt;

&lt;p&gt;If you remember, we spoke about stratification previously. Let’s take the original integral &lt;script type=&quot;math/tex&quot;&gt;\int_0^2 x^2&lt;/script&gt;. To stratify the points, we’ll divide the interval in 4 bins. If I am taking N samples, we are going to take &lt;script type=&quot;math/tex&quot;&gt;\frac{n}{4}&lt;/script&gt; samples per bin, so let’s call this value &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;. The Monte Carlo estimate using stratified sampling now looks like this:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_0^2 x^2 = (0.5 - 0)\frac{1}{k} \sum_{i=0}^{k} x_1^2 + 
(1.0 - 0.5)\frac{1}{k} \sum_{i=0}^{k} x_2^2 +
\\
(1.5 - 1)\frac{1}{k} \sum_{i=0}^{k} x_3^2 +
(2 - 1.5)\frac{1}{k} \sum_{i=0}^{k} x_4^2&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;x_1&lt;/script&gt; is a random number between 0 and 0.5, &lt;script type=&quot;math/tex&quot;&gt;x_2&lt;/script&gt; is between 0.5 and 1.0, &lt;script type=&quot;math/tex&quot;&gt;x_3&lt;/script&gt; between 1.0 and 1.5, and &lt;script type=&quot;math/tex&quot;&gt;x_4&lt;/script&gt; between 1.5 and 2, giving us a total of &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; samples.&lt;/p&gt;

&lt;p&gt;Here is a self contained program showing the stratified and naive Monte Carlo estimations.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;simpleMcRes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;samples&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bins&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;samplesPerBin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;samples&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binStart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binStart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;samplesPerBin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;drand48&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;simpleMcRes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

			&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;drand48&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;simpleMcRes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;simpleMcRes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;samples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;samples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Simple MC: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;simpleMcRes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Stratified MC: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Stratification warrants its own post following some discussions with some friends. I wanted to show certain properties but felt that this post would be too long.&lt;/p&gt;

&lt;p&gt;That’s pretty much it for this post, next up is Chapter 3 and 4.&lt;/p&gt;

&lt;p&gt;If you have any questions and feedback, feel free to comment or contact me via twitter/email.&lt;/p&gt;</content><author><name>Darryl Gouder</name></author><summary type="html">Welcome back! If you’re joining from the 1st post, you can skip ahead and start reading from the Chapter 2 title. If not, here’s a link to the first post as there’s some information in the beginning about this blog series. Chapter 2: One Dimensional MC Integration Monte Carlo is widely used to solve integrals of higher dimensions, where an analytical method is not possible, or other integral computational methods are intractable. Dr. Shirley selects a simple integral to show how effective Monte Carlo integration is. Start reading the chapter right until you get to the code that computes the integral. Don’t worry if you don’t get it, I’m going to explain everything. The integral is which will compute the area under the curve, with the limits 0 to 2. So how do we translate this into a Monte Carlo estimate? I was a bit confused by the sudden appearance of the 2 being multiplied with the average(x^2, 0, 2) function. Why are we multiplying the sample average by 2? Well as it turns out, this how we perform Monte Carlo integration. A generic integral of the form: can be estimated with a Monte Carlo estimator by performing</summary></entry><entry><title type="html">Ray Tracing The Rest of Your Life: A reader’s companion, Chapter 1</title><link href="http://localhost:4000/rendering/2019/02/15/rt_rc_chapter1/" rel="alternate" type="text/html" title="Ray Tracing The Rest of Your Life: A reader's companion, Chapter 1" /><published>2019-02-15T00:00:00+00:00</published><updated>2019-02-15T00:00:00+00:00</updated><id>http://localhost:4000/rendering/2019/02/15/rt_rc_chapter1</id><content type="html" xml:base="http://localhost:4000/rendering/2019/02/15/rt_rc_chapter1/">&lt;p&gt;This blog series is a set of notes that expand on Dr Shirley’s “Ray Tracing The Rest of Your Life” book. The book is compact, introducing all the tools that one will need in their arsenal to build a sophisticated ray tracer. I found it very refreshing in terms of simplifying otherwise esoteric concepts and bridging the gap between simple mathematical concepts and their application in ray tracing.&lt;/p&gt;

&lt;p&gt;My journey through the book raised many questions, which Dr Shirley was very helpful in answering and explaining. Along the way I read many different articles and saw different videos to understand things. I am probably not the only person who needed help understanding things and won’t be the last, so I thought it would be a good idea to share the information that I gathered.&lt;/p&gt;

&lt;p&gt;The format of this post is unconventional  - you should have a copy of &lt;a href=&quot;http://www.realtimerendering.com/raytracing/Ray%20Tracing_%20the%20Rest%20of%20Your%20Life.pdf&quot; target=&quot;_blank&quot;&gt;the book&lt;/a&gt; (ideally the PDF as it is the most recent updated) open in another tab. I’ll try to guide you as best as I can throughout the book by asking you to look at the book and come back when you reach a certain point.&lt;/p&gt;
&lt;p align=&quot;center&quot; style=&quot;color:red;&quot;&gt;
&lt;b&gt;These statements will be in bold and red! &lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Re-reading is also very important - it’s very hard to understand everything at a first read. Don’t worry too much if you don’t get everything immediately. These are not straightforward concepts so just keep at it. If you feel truly stuck, reach out to me and we’ll try to clear things up. With all that said, let’s start.&lt;/p&gt;

&lt;h1 id=&quot;chapter-1-a-simple-monte-carlo-program&quot;&gt;Chapter 1: A Simple Monte Carlo Program&lt;/h1&gt;

&lt;p&gt;The first chapter is very straightforward. Demonstrating Monte Carlo by estimating &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt; is a prevalent computational statistics example.&lt;/p&gt;

&lt;p&gt;The code snippet for this that is presented in the book is very simple and self explanatory. A point is generated inside a square and if it is inside the circle, we increase the counter tracking the number of points inside the circle. We divide this final count by the total number of points we generate to get an average answer to &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt;.&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;color:red;&quot;&gt;
&lt;b&gt;
It’s time to go look at the book - read up until the you get to the 2nd code snippet, involving the running \(\pi\) calculation program.
&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;One of the questions of those uninitiated in probability and Monte Carlo theory might be: How does this type of computation work and how does it end up giving us an estimate of &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt;? This stems from what is known as the &lt;strong&gt;expected value&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;A classic example in explaining the expected value is trying to answer the question:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
What is the probability that I will get a heads, when I flip a fair coin?
&lt;/p&gt;

&lt;p&gt;We know intuitively that it is 0.5. However what the expected value theory shows us is that if we&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;get an actual fair coin,&lt;/li&gt;
  &lt;li&gt;start flipping it,&lt;/li&gt;
  &lt;li&gt;take note of each result,&lt;/li&gt;
  &lt;li&gt;count the number of heads and tails,&lt;/li&gt;
  &lt;li&gt;average them,&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We will probably get a result close to 0.5. The more times we toss the coin, the closer to 0.5 the answer will be.&lt;/p&gt;

&lt;p&gt;The mathematical notation used to describe the expected value is:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E[X] = \sum_{i=1}^k x_i p_i = x_1 p_1 + x_2 p_2 + ... + x_k p_k&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;E[X]&lt;/script&gt; is the expected value of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;, our statistical experiment.&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;x_i&lt;/script&gt; is the result of each sample that we compute of our function&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;p_i&lt;/script&gt; is the probability weight of this sample. They must sum up to 1.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’ll use another example rather than a coin toss to tie with the above equation. If we had a fair 6-sided dice, the expected value would be:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E[X] = \sum_{i=1}^k x_i p_i = \frac{1}{6} + \frac{2}{6} + \frac{3}{6} +  \frac{4}{6} + \frac{5}{6} + \frac{6}{6} = 3.5&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;x_i&lt;/script&gt; was the dice roll and $$ \frac{1}{6} was the probability weight. If dice wasn’t fair, the weights would be different - that doesn’t matter as long as they sum up to one.&lt;/p&gt;

&lt;p&gt;Back to our original monte carlo example, the reason why this works is a theorem known as the &lt;strong&gt;Law of Large Numbers&lt;/strong&gt;. The weak law of large numbers states that if we take a number of samples and average them, it will &lt;em&gt;PROBABLY&lt;/em&gt; converge to the expected value. The strong law of large numbers states that it will converge &lt;em&gt;ALMOST SURELY&lt;/em&gt; (with probability 1). We’re not going to go down this rabbit hole, the one of interest to us in the weak law.&lt;/p&gt;

&lt;p&gt;An important term that we should define is &lt;strong&gt;variance&lt;/strong&gt;. In our example, we were trying to compute &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt;, which makes this  the mean we’re trying to estimate. The variance, in very informal language, measures how spread out our sample computations are from this mean. The lower the variance, the less spread out the samples are and the more accurate our computed mean is to the expected value (the expected value is also known as the mean). If we have high variance, this means our samples are spread out, and we might be using an ineffective function to computationally find our mean. There are ways to quantify variance which are useful for estimating the error of our Monte Carlo techniques, however I think it would not be fruitful for now to discuss those.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;Law of Diminishing Returns&lt;/strong&gt; explains the idea that the more samples we take, the more we need than before, to get an accurate answer.  In terms of numbers, if you want to half the error that you’re getting, you’ll need to quadruple the amount of samples. Here is how the error between our estimated value of &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt; and actual &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt; decreases as we compute more samples.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/posts/rt_rc_chapter1/pi_estimate.png&quot; alt=&quot; $$ \pi $$ Estimate error&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Notice how after sample 200, the error doesn’t decrease that much. This doesn’t hold a lot of significance for now but it’s good to keep this in mind.&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;color:red;&quot;&gt;
&lt;b&gt;Now would be a good time to go read the rest of the chapter.&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;Stratification is a way of intelligently placing your samples to estimate your function better. If you look at my &lt;a href=&quot;https://dargouder.github.io/darryls-pixels/mathematics/2018/07/04/prngs/&quot; target=&quot;_blank&quot;&gt;blog post&lt;/a&gt; about random numbers, I show that a good PRNG (Pseudo-Random Number Generator) should generate uniformly distributed points. When you’re dealing with multiple dimensions a PRNG’s inherent randomness isn’t enough. Think of dimensions this way: you need 2 uniform random numbers for your primary ray, then 2 for your lens, then another 2 for your next bounce and so forth. Everytime, you’re adding another dimension and although your random numbers are unifornm if we look at them at being in the same dimension, it may not necessarily be the case when used in these different dimensions. To ensure true uniformity, without having clustered samples, we stratify the samples we take.&lt;/p&gt;

&lt;p&gt;The careful selection of samples to minimize variance is an ongoing area of research, that is an absolutely fascinating subject and one of my favourite topics in CG. Dr. Shirley expands on this topic is in this blog post: &lt;a href=&quot;http://psgraphics.blogspot.com/2018/10/flavors-of-sampling-in-ray-tracing.html&quot; target=&quot;_blank&quot;&gt;Flavors of sampling in ray tracing&lt;/a&gt;. Leonhard Grünschloß has some excellent implementations of different &lt;a href=&quot;http://gruenschloss.org/&quot; target=&quot;_blank&quot;&gt;Quasi-Monte Carlo based samplers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I’ll slightly re-visit stratification at the end of Chapter 2, once we define the Monte Carlo Integral and importance sampling. The topic warrants tons of blog posts, maybe someday…&lt;/p&gt;

&lt;p&gt;The next post will focus on Chapter 2, where I’ll delve ever so slightly into Monte Carlo theory and we’ll perform some interesting computations.&lt;/p&gt;

&lt;p&gt;If you have any questions and feedback, feel free to comment or contact me via twitter/email.&lt;/p&gt;</content><author><name>Darryl Gouder</name></author><summary type="html">This blog series is a set of notes that expand on Dr Shirley’s “Ray Tracing The Rest of Your Life” book. The book is compact, introducing all the tools that one will need in their arsenal to build a sophisticated ray tracer. I found it very refreshing in terms of simplifying otherwise esoteric concepts and bridging the gap between simple mathematical concepts and their application in ray tracing. My journey through the book raised many questions, which Dr Shirley was very helpful in answering and explaining. Along the way I read many different articles and saw different videos to understand things. I am probably not the only person who needed help understanding things and won’t be the last, so I thought it would be a good idea to share the information that I gathered. The format of this post is unconventional - you should have a copy of the book (ideally the PDF as it is the most recent updated) open in another tab. I’ll try to guide you as best as I can throughout the book by asking you to look at the book and come back when you reach a certain point. These statements will be in bold and red! Re-reading is also very important - it’s very hard to understand everything at a first read. Don’t worry too much if you don’t get everything immediately. These are not straightforward concepts so just keep at it. If you feel truly stuck, reach out to me and we’ll try to clear things up. With all that said, let’s start. Chapter 1: A Simple Monte Carlo Program The first chapter is very straightforward. Demonstrating Monte Carlo by estimating is a prevalent computational statistics example. The code snippet for this that is presented in the book is very simple and self explanatory. A point is generated inside a square and if it is inside the circle, we increase the counter tracking the number of points inside the circle. We divide this final count by the total number of points we generate to get an average answer to . It’s time to go look at the book - read up until the you get to the 2nd code snippet, involving the running \(\pi\) calculation program. One of the questions of those uninitiated in probability and Monte Carlo theory might be: How does this type of computation work and how does it end up giving us an estimate of ? This stems from what is known as the expected value. A classic example in explaining the expected value is trying to answer the question: What is the probability that I will get a heads, when I flip a fair coin? We know intuitively that it is 0.5. However what the expected value theory shows us is that if we get an actual fair coin, start flipping it, take note of each result, count the number of heads and tails, average them, We will probably get a result close to 0.5. The more times we toss the coin, the closer to 0.5 the answer will be. The mathematical notation used to describe the expected value is: is the expected value of , our statistical experiment. is the result of each sample that we compute of our function is the probability weight of this sample. They must sum up to 1. I’ll use another example rather than a coin toss to tie with the above equation. If we had a fair 6-sided dice, the expected value would be: where was the dice roll and $$ \frac{1}{6} was the probability weight. If dice wasn’t fair, the weights would be different - that doesn’t matter as long as they sum up to one. Back to our original monte carlo example, the reason why this works is a theorem known as the Law of Large Numbers. The weak law of large numbers states that if we take a number of samples and average them, it will PROBABLY converge to the expected value. The strong law of large numbers states that it will converge ALMOST SURELY (with probability 1). We’re not going to go down this rabbit hole, the one of interest to us in the weak law. An important term that we should define is variance. In our example, we were trying to compute , which makes this the mean we’re trying to estimate. The variance, in very informal language, measures how spread out our sample computations are from this mean. The lower the variance, the less spread out the samples are and the more accurate our computed mean is to the expected value (the expected value is also known as the mean). If we have high variance, this means our samples are spread out, and we might be using an ineffective function to computationally find our mean. There are ways to quantify variance which are useful for estimating the error of our Monte Carlo techniques, however I think it would not be fruitful for now to discuss those. The Law of Diminishing Returns explains the idea that the more samples we take, the more we need than before, to get an accurate answer. In terms of numbers, if you want to half the error that you’re getting, you’ll need to quadruple the amount of samples. Here is how the error between our estimated value of and actual decreases as we compute more samples. Notice how after sample 200, the error doesn’t decrease that much. This doesn’t hold a lot of significance for now but it’s good to keep this in mind. Now would be a good time to go read the rest of the chapter. Stratification is a way of intelligently placing your samples to estimate your function better. If you look at my blog post about random numbers, I show that a good PRNG (Pseudo-Random Number Generator) should generate uniformly distributed points. When you’re dealing with multiple dimensions a PRNG’s inherent randomness isn’t enough. Think of dimensions this way: you need 2 uniform random numbers for your primary ray, then 2 for your lens, then another 2 for your next bounce and so forth. Everytime, you’re adding another dimension and although your random numbers are unifornm if we look at them at being in the same dimension, it may not necessarily be the case when used in these different dimensions. To ensure true uniformity, without having clustered samples, we stratify the samples we take. The careful selection of samples to minimize variance is an ongoing area of research, that is an absolutely fascinating subject and one of my favourite topics in CG. Dr. Shirley expands on this topic is in this blog post: Flavors of sampling in ray tracing. Leonhard Grünschloß has some excellent implementations of different Quasi-Monte Carlo based samplers. I’ll slightly re-visit stratification at the end of Chapter 2, once we define the Monte Carlo Integral and importance sampling. The topic warrants tons of blog posts, maybe someday… The next post will focus on Chapter 2, where I’ll delve ever so slightly into Monte Carlo theory and we’ll perform some interesting computations.</summary></entry><entry><title type="html">Pseudo Random Number Generation</title><link href="http://localhost:4000/mathematics/2018/07/04/prngs/" rel="alternate" type="text/html" title="Pseudo Random Number Generation" /><published>2018-07-04T10:30:00+01:00</published><updated>2018-07-04T10:30:00+01:00</updated><id>http://localhost:4000/mathematics/2018/07/04/prngs</id><content type="html" xml:base="http://localhost:4000/mathematics/2018/07/04/prngs/">&lt;p&gt;In this post I’ll talk a bit about pseudo random number generation. This will be the first in an assortment of posts regarding monte carlo methods.&lt;/p&gt;

&lt;p&gt;I’ll assume you have working knowledge of calculus and some probability and statistics.&lt;/p&gt;

&lt;p&gt;The most essential aspect of any form of monte carlo method is the generation of random numbers. Uniformly distributed random numbers on the interval [0,1] are what we’d like to generate first, as they are also what is required for the other types of distributions.&lt;/p&gt;

&lt;p&gt;Generating random numbers using a pseudo random number generator (PRNG) means that we generate a sequence of numbers, using some particular seed value (some arbitrary constant) that initializes the random number generation algorithm. We use the term pseudo, because the numbers generated are not truly random but generated deterministically and hence can be replicated if the same seed and the same constants in the function are used. This is ideal for us, so that we can replicate and debug our algorithms. We can think of these algorithms as generating a deterministic sequence which is based on a starting point.&lt;/p&gt;

&lt;p&gt;For this sequence to be considered to be of good quality, it should have certain properties, such as lack of predictibility (i.e. if we generate x values, and we can guess the next, this means the predctibility is possible) and equidistribution. For example if the mean of a large sequence of uniformly distributed numbers in the range [0,1] is not 0.5, then it is likely that something is wrong with the PRNG, given that due to the Law of Large Numbers, we would expect the arithmetic mean of this sequence to be similar to the expected mean (the expected mean being 0.5). We won’t focus on hardcore evaluation PRNGs and leave that to other minds, some useful links are &lt;a href=&quot;http://pit-claudel.fr/clement/blog/how-random-is-pseudo-random-testing-pseudo-random-number-generators-and-measuring-randomness/&quot; target=&quot;_blank&quot;&gt;“How random is pseudorandom testing pseudorandom number generators and measuring randomness”&lt;/a&gt; and &lt;a href=&quot;http://simul.iro.umontreal.ca/testu01/tu01.html&quot; target=&quot;_blank&quot;&gt;TestU01 tests&lt;/a&gt;. We’ll look at 2 PRNGs and do some simple tests to measure their quality.&lt;/p&gt;

&lt;p&gt;Let’s look at a simple PRNG known as the Linear Congruential Generator (which I’ll now continue referring to as LCG).&lt;/p&gt;

&lt;p&gt;The LCG is an easy-to-implement PRNG, the function definition being:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://latex.codecogs.com/gif.latex?X_{n&amp;plus;1}=&amp;space;(a&amp;space;*&amp;space;X_n&amp;space;&amp;plus;&amp;space;c)&amp;space;\bmod&amp;space;m&quot; title=&quot;X_{n+1}= (a * X_n + c) \bmod m&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;where:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;m&lt;/strong&gt; is the modulus constant, and &lt;strong&gt;m&lt;/strong&gt; &amp;gt; 0.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;a&lt;/strong&gt; is the multiplier, and 0 &amp;lt; &lt;strong&gt;a&lt;/strong&gt; &amp;lt; &lt;strong&gt;m&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;c&lt;/strong&gt; is the increment, 0 &amp;lt;= &lt;strong&gt;c&lt;/strong&gt; &amp;lt;= &lt;strong&gt;m&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt; is the seed value, 0 &amp;lt;= &lt;strong&gt;X&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt; &amp;lt; &lt;strong&gt;m&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The above constants are all integers. Careful selection of these values ensures that the sequence we get is of a high quality.&lt;/p&gt;

&lt;p&gt;Here’s an R listing of what the code for this should look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;&lt;span class=&quot;n&quot;&gt;lcgen&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1229&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2048&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;+1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;+1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;N is the number of random numbers we want to generate. Let’s generate 1000 samples and plot a histogram to look at the distribution.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/prngs/lcg_histogram.png&quot; alt=&quot;LCG histogr§am&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;It’s fair to say, the distribution of samples looks good. Given that the generation of a value is dependent on the next let’s see if we can see a pattern by plotting them in a time series.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/prngs/lcg_time_series.png&quot; alt=&quot;LCG Time Series&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;That looks pretty random, so let’s plot them in series, taking pairs as cartesian coordinates (x_2k-1, x_2k). This type of test is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Autocorrelation&quot; target=&quot;_blank&quot;&gt;autocorrelation&lt;/a&gt;.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/prngs/lcg_2d.png&quot; alt=&quot;LCG 2D Autocorrelation&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Well that’s interesting, pairs line up as lines… what if we plot them in 3D?&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/prngs/lcg_3d.gif&quot; alt=&quot;LCG 3D Autocorrelation&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;The numbers are forming a line in 2D, a plane in 3D and this pattern continues in n-dimensions, where a n-dimensional hyperplane is formed for the n’th dimension. George Marsaglia identified this issue in 1968 and it is now know as the Marsaglia Theorem. He pointed out the worrying conclusion that all the papers that had used a LCG as their PRNG of choice might have wrong results. This highlights the importance of using a good PRNG.&lt;/p&gt;

&lt;p&gt;From now on we’ll use a PRNG of a higher quality, the Mersenne Twister. I won’t go into its implementation, it’s a lot more sophisticated and robust than the LCG. The more recent &lt;a href=&quot;http://www.pcg-random.org/&quot; target=&quot;_blank&quot;&gt;PCG PRNG&lt;/a&gt; is better than Mersenne and it’s what I use in my rendering system. Having said that, R’s runif (short for random uniform) command uses the Mersenne Twister algorithm, and for these posts it should suffice. PBRT 2 used to use Mersenne Twister and PBRT V3 uses PCG.&lt;/p&gt;

&lt;p&gt;If we re-run the above tests using Mersenne Twister, we can see that, the histogram looks acceptable,&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/prngs/mersenne_hist.png&quot; alt=&quot;Mersenne Histogram&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;so does the time series plot,&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/prngs/mersenne_time_series.png&quot; alt=&quot;Mersenne Time Series&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;and the 2D plot (points look to be well distributed in the 2D plane)&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/prngs/mersenne_2d.png&quot; alt=&quot;Mersenne 2D Autocorrelation&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;and the 3D plot (points look to be well distributed in the 3D unit cube).&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/prngs/mersenne_3d.gif&quot; alt=&quot;Mersenne 3D Autocorrelation&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Whenever you see runif, assume the numbers are well uniformly-distributed using the Mersenne Twister algorithm. Now that we’ve understood a bit more how uniform random numbers are generated, I’ll later post about transforming these uniform random numbers into other forms of distributions, e.g. normally distributed.&lt;/p&gt;</content><author><name>Darryl Gouder</name></author><summary type="html">In this post I’ll talk a bit about pseudo random number generation. This will be the first in an assortment of posts regarding monte carlo methods. I’ll assume you have working knowledge of calculus and some probability and statistics. The most essential aspect of any form of monte carlo method is the generation of random numbers. Uniformly distributed random numbers on the interval [0,1] are what we’d like to generate first, as they are also what is required for the other types of distributions. Generating random numbers using a pseudo random number generator (PRNG) means that we generate a sequence of numbers, using some particular seed value (some arbitrary constant) that initializes the random number generation algorithm. We use the term pseudo, because the numbers generated are not truly random but generated deterministically and hence can be replicated if the same seed and the same constants in the function are used. This is ideal for us, so that we can replicate and debug our algorithms. We can think of these algorithms as generating a deterministic sequence which is based on a starting point. For this sequence to be considered to be of good quality, it should have certain properties, such as lack of predictibility (i.e. if we generate x values, and we can guess the next, this means the predctibility is possible) and equidistribution. For example if the mean of a large sequence of uniformly distributed numbers in the range [0,1] is not 0.5, then it is likely that something is wrong with the PRNG, given that due to the Law of Large Numbers, we would expect the arithmetic mean of this sequence to be similar to the expected mean (the expected mean being 0.5). We won’t focus on hardcore evaluation PRNGs and leave that to other minds, some useful links are “How random is pseudorandom testing pseudorandom number generators and measuring randomness” and TestU01 tests. We’ll look at 2 PRNGs and do some simple tests to measure their quality. Let’s look at a simple PRNG known as the Linear Congruential Generator (which I’ll now continue referring to as LCG). The LCG is an easy-to-implement PRNG, the function definition being: where: m is the modulus constant, and m &amp;gt; 0. a is the multiplier, and 0 &amp;lt; a &amp;lt; m. c is the increment, 0 &amp;lt;= c &amp;lt;= m. X0 is the seed value, 0 &amp;lt;= X0 &amp;lt; m. The above constants are all integers. Careful selection of these values ensures that the sequence we get is of a high quality. Here’s an R listing of what the code for this should look like: lcgen &amp;lt;- function(x0=4, N, a=1229, c=1, m=2048) { x = c() x[1] = x0 for(n in 2:(N+1)) { x[n] = (a * x[n-1] + c) %% m } return (x[2:(N+1)]/m) } N is the number of random numbers we want to generate. Let’s generate 1000 samples and plot a histogram to look at the distribution.</summary></entry><entry><title type="html">Hello embree</title><link href="http://localhost:4000/rendering/2018/05/27/hello-embree/" rel="alternate" type="text/html" title="Hello embree" /><published>2018-05-27T10:30:00+01:00</published><updated>2018-05-27T10:30:00+01:00</updated><id>http://localhost:4000/rendering/2018/05/27/hello-embree</id><content type="html" xml:base="http://localhost:4000/rendering/2018/05/27/hello-embree/">&lt;p&gt;I’ve been slowly developing a raytracer which has been a lot of fun and a great learning experience both from a technical standpoint and the theoretical side of physically-based rendering.&lt;/p&gt;

&lt;p&gt;I’m at a point now where I am importing meshes of a larger nature, and I was not content with my BVH implementation. As much as I would like to read the state of the art papers on BVH construction and traversal and implement them myself, I’ve decided to opt to use embree instead. I would rather focus on the light transport part and focus on getting prettier images and getting them to converge quicker from an algorithmic standpoint. As a friend of mine said, I have to pick my battles, and embree is going to do a lot of heavy lifting for me so that I can focus more on what I’d like to write.&lt;/p&gt;

&lt;p&gt;Setting up embree with CMake is quite easy &lt;a href=&quot;https://bitbucket.org/dgouder/embree-renderer/src/master/&quot; target=&quot;_blank&quot;&gt;I’ve got the full source code of this post available here&lt;/a&gt;	, and I won’t go into details into how to set it up - the CMakeLists.txt is quite self explanatory and I’ve added as much comments as I can.&lt;/p&gt;

&lt;p&gt;As great and as fleshed out the samples are, there is a lot of boilerplate code, written in different header files. This put me off initially but with a bit of digging, and building the samples with a powerful IDE went long way in help way in helping me zip around the API and the headers.&lt;/p&gt;

&lt;p&gt;I thought it would be interesting to write the simplest thing I can think of with embree, a hello world ray tracing example if you will, I’ll explain below what we’ll do.&lt;/p&gt;

&lt;h3 id=&quot;what-is-embree&quot;&gt;What is embree?&lt;/h3&gt;

&lt;p&gt;Embree is a high-performance ray tracing kernel library written by Intel. It contains state-of-the-art implementations of acceleration structure and intersection methods, and provide a plethora of features to write a performant ray tracer. More details can be found here, and in their white paper. They target the Intel architecture specifically and are highly optimized using SIMD intrinsics to push as much as performance as possible.&lt;/p&gt;

&lt;h3 id=&quot;hello-embree&quot;&gt;Hello Embree!&lt;/h3&gt;

&lt;p&gt;My toy example shoots a ray per pixel and returns white if nothing is hit and black if the triangle places in the centre of the image is hit. This is the main function:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Inititiate device and scene
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Add geometry to scene
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Initiate image parameters, image and camera
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Render image
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Output image
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Release scene
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll work through each of these with a short explanation for everything. The full source code listing can be found here. It is self contained, with embree being part of the sources. If you have any issues with compilation, feel free to contact me.&lt;/p&gt;

&lt;p&gt;If you want to skip ahead:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#device-initiation&quot;&gt;Device initiation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#adding-geometry-to-the-scene&quot;&gt;Adding geometry to the scene&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#creating-the-triangle-geometry-and-defining-the-vertices&quot;&gt;Creating the triangle geometry and defining the vertices&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#render-image&quot;&gt;Render image&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#output-image&quot;&gt;Output image&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#release-scene&quot;&gt;Release scene&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;device-initiation&quot;&gt;Device initiation&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Inititiate device and scene
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RTCDevice&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rtcNewDevice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RTCScene&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rtcNewScene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The device object is defined to be a class factory for all the other objects that we’ll be creating such as the scene and the geometry, using the &lt;a href=&quot;https://embree.github.io/api.html#rtcnewdevice&quot; target=&quot;_blank&quot;&gt;rtcNewDevice&lt;/a&gt; call. The device handle is not destroyed until all objects bound with the device are released. Embree uses reference counting to keep track of the lifetime of all the objects you create - functions with the word release decrease the reference counter. It’s very important to use the release functions, otherwise you’re leaking memory. I’ve heard that for every byte of leaked memory, a kitten drowns and we don’t want that now do we?&lt;/p&gt;

&lt;p&gt;The new scene is created and bound to the device previously created.&lt;/p&gt;

&lt;h3 id=&quot;adding-geometry-to-the-scene&quot;&gt;Adding geometry to the scene&lt;/h3&gt;

&lt;p&gt;We now need to define and add the geometry to our scene. I’m just going to create a triangle in the middle of the screen.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Create a new geometry for the triangle
// Define the vertices
// Assign the vertices to the geometry buffer 
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Commit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;geometry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;creating-the-triangle-geometry-and-defining-the-vertices&quot;&gt;Creating the triangle geometry and defining the vertices&lt;/h4&gt;

&lt;p&gt;We’ll need to allocate memory for our geometry:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Create a new geometry for the triangle
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RTCGeometry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rtcNewGeometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTC_GEOMETRY_TYPE_TRIANGLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Vertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rtcSetNewGeometryBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTC_BUFFER_TYPE_VERTEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTC_FORMAT_FLOAT3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We create a geometry object using &lt;a href=&quot;https://embree.github.io/api.html#rtcnewgeometry&quot;&gt;rtcNewGeometry&lt;/a&gt;, which is attached to our device and we’ve picked a triangle to be our geometry of choice. Embree has a selection of different geometry types available, which you can find inside the documenation. Once we’ve created our geometry object, we create a buffer for the vertices, using &lt;a href=&quot;https://embree.github.io/api.html#rtcsetnewgeometrybuffer&quot;&gt;rtcSetNewGeometryBuffer&lt;/a&gt;. We’ll use this function to set the indices later on. The key here is the second parameter, RTC_BUFFER_TYPE_VERTEX.&lt;/p&gt;

&lt;p&gt;Next is the vertices:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Define the vertices
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Nothing extraordinary here - just defining the positions of the vertices. We’ll now assign these indices to our buffer:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Assign the vertices to the geometry buffer
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Triangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;triangles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Triangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rtcSetNewGeometryBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTC_BUFFER_TYPE_INDEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTC_FORMAT_UINT3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Triangle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;triangles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;triangles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;triangles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re now setting up an index buffer for the vertices. Looking at this from a birds eye view, it’s quite similar to how things are done in OpenGL. We’re not done yet though. We need to commit the geometry and the scene.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Commit geometry to the scene
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rtcCommitGeometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;geomID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rtcAttachGeometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rtcReleaseGeometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rtcCommitScene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So what does this all mean? The &lt;a href=&quot;https://embree.github.io/api.html#rtccommitgeometry&quot; target=&quot;_blank&quot;&gt;rtcCommitGeometry&lt;/a&gt; call commits all the modifications to the geometry and has to be called each time we modify the geometry.&lt;/p&gt;

&lt;p&gt;We then attach the geometry to the scene using &lt;a href=&quot;https://embree.github.io/api.html#rtcattachgeometry&quot; target=&quot;_blank&quot;&gt;rtcAttachGeometry&lt;/a&gt;. The &lt;a href=&quot;https://embree.github.io/api.html#rtcreleasegeometry&quot; target=&quot;_blank&quot;&gt;rtcReleaseGeometry&lt;/a&gt; call decreases the reference count of each piece of geometry. I was quite curious when I saw this and I think it’s because rtcAttachGeometry increase a reference to the mesh by the scene, so the original mesh handle can be disposed of. To commit our scene we’ll need to call rtcCommitScene which builds our spatial data structure. Everytime we modify the geometry, we need to go through this step. We can commit to the scene all once though, as you’ll not might notice in my actual source code that the commit is right after the call to the function that defines the geometry. You can define and commit all your geometry at once and then have a single called right after these definitions.&lt;/p&gt;

&lt;p&gt;We’ll initiate the image and the camera parameters.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Initiate image parameters, image and camera
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;600&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vec3fa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lower_left_corner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vec3fa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;horizontal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vec3fa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertical&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vec3fa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;origin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you’re not familiar with regards to the parameters of the camera, I’d suggest reading up on primary ray generation and the camera model. I might do a post about this later as I used to struggle with this a while back. Now that I’ve said this in public I’ll be forced to do it :)&lt;/p&gt;

&lt;p&gt;Nothing too fancy here, just define the image parameters and the camera parameters for the primary ray generation.&lt;/p&gt;

&lt;p&gt;The next part is where we get to test the ray intersection!&lt;/p&gt;

&lt;h3 id=&quot;render-image&quot;&gt;Render image&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Render image
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Initiate pixel colour
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vec3fa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vec3fa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Create ray intersection context
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// Generate ray
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// Perform ray intersection
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// Check if ray intersected any geometry
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// Set pixel colour
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll now define the intersection context:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Create ray intersection context
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RTCIntersectContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rtcInitIntersectContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We use the RTCIntersectContext for your ray intersection test. &lt;a href=&quot;https://embree.github.io/api.html#rtcinitintersectcontext&quot; target=&quot;_blank&quot;&gt;rtcInitIntersectContext&lt;/a&gt; takes flags which can optimize the performance of the ray tracer, such as indicating that the rays are coherent.&lt;/p&gt;

&lt;p&gt;This is the primary ray generation stolen from Dr. Shirley’s Ray Tracing in One Weekend book.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Generate ray
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vec3fa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lower_left_corner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;horizontal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertical&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Ray&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;origin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once we have the ray set up, all we need to do is perform a ray intersection test using an embree function suited for &lt;a href=&quot;https://embree.github.io/api.html#rtcintersect1&quot; target=&quot;_blank&quot;&gt;single ray intersection tests&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Perform ray intersection
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rtcIntersect1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTCRayHit_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We need to pass in the scene and the context. The RTCRayHit_ function constructs the embree ray-type from the one that type that we defined ourselves. In reality our ray is very similar to what’s the defined in embree. The intersection information is stored in the ray, and checked:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Check if ray intersected any geometry
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;geomID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTC_INVALID_GEOMETRY_ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vec3fa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and that’s it! The embree specific stuff ends here. I haven’t included the ray definition and the auxiliary functions to convert because they’re one liners and you can have a poke around in the repo. We then set the colour of the pixel:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Set pixel colour
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and repeat the whole process for each pixel. When that’s done, we spit out our png:&lt;/p&gt;

&lt;h3 id=&quot;output-image&quot;&gt;Output image&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Output image
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lodepng&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello.png&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;encoder error &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lodepng_error_text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’m using lodepng to write the image to file, nothing too complex going on here, and then we get this!&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/hello-embree/hello.png&quot; alt=&quot;Hello embree&quot; /&gt;
&lt;/p&gt;

&lt;h3 id=&quot;release-scene&quot;&gt;Release scene&lt;/h3&gt;

&lt;p&gt;Now we should clean up after ourselves and leave no memory leaks&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Release the scene
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rtcReleaseScene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and that’s pretty much it.&lt;/p&gt;

&lt;p&gt;Thanks for reading, I know this was quite verbose but I hope it was helpful. Embree’s extensive features means that it’s now significantly easier to write a high-performant ray tracer. I’m very excited in doing more fleshed out examples and melding it with my own ray tracer. I will have to probably change a lot from an architectural standpoint but the performance gains warrant it. If you have any questions feel free to ask, I may not necessarily know the answer but learning is part of the fun and will do what I can to help :)&lt;/p&gt;</content><author><name>Darryl Gouder</name></author><summary type="html">I’ve been slowly developing a raytracer which has been a lot of fun and a great learning experience both from a technical standpoint and the theoretical side of physically-based rendering. I’m at a point now where I am importing meshes of a larger nature, and I was not content with my BVH implementation. As much as I would like to read the state of the art papers on BVH construction and traversal and implement them myself, I’ve decided to opt to use embree instead. I would rather focus on the light transport part and focus on getting prettier images and getting them to converge quicker from an algorithmic standpoint. As a friend of mine said, I have to pick my battles, and embree is going to do a lot of heavy lifting for me so that I can focus more on what I’d like to write. Setting up embree with CMake is quite easy I’ve got the full source code of this post available here , and I won’t go into details into how to set it up - the CMakeLists.txt is quite self explanatory and I’ve added as much comments as I can. As great and as fleshed out the samples are, there is a lot of boilerplate code, written in different header files. This put me off initially but with a bit of digging, and building the samples with a powerful IDE went long way in help way in helping me zip around the API and the headers. I thought it would be interesting to write the simplest thing I can think of with embree, a hello world ray tracing example if you will, I’ll explain below what we’ll do.</summary></entry></feed>