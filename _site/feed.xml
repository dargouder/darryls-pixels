<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-02-05T14:12:51+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Darryl’s Pixels</title><subtitle>Blog about code and stuff...</subtitle><author><name>Darryl Gouder</name></author><entry><title type="html">Measuring the Rendering Equation</title><link href="http://localhost:4000/mathematics,/rendering,/graphics/2028/08/15/radiometry_rend_eq/" rel="alternate" type="text/html" title="Measuring the Rendering Equation" /><published>2028-08-15T10:30:00+01:00</published><updated>2028-08-15T10:30:00+01:00</updated><id>http://localhost:4000/mathematics,/rendering,/graphics/2028/08/15/radiometry_rend_eq</id><content type="html" xml:base="http://localhost:4000/mathematics,/rendering,/graphics/2028/08/15/radiometry_rend_eq/">&lt;p&gt;The root concept of all computer graphics is the propogation light, and how we describe and measure its propogration throughout a scene. In the case of physically based rendering, physics is our ground truth, therefore the quantities used to measure light and the ideas on how the light behaves under arbitrary conditions are an attractive and elegant way of simulating light transport. At the root all these physical ideas is radiometry.&lt;/p&gt;

&lt;p&gt;This is a topic that I initially did not hold as much appreciation as I should have when I first started out in computer graphics, however I’ve come to realize that understanding radiometry well will lead to a more intuitive understanding of many different concepts in PBR. In this blog post, I’ll use various sources to write at length about the different radiometric quantities, with examples and as many visual cues as possible.&lt;/p&gt;

&lt;p&gt;Light is the visible part of the electromagnetic spectrum and therefor subject to all the ideas that we have regarding the behaviour of electromagnetic radiation. Most of us are familiar with the speed of light, approximately measured at 299,792,458 metres per second in a vacuum. This value is a commonly referred to as c and is part of a special group known as universal constants - a value which is constant both in the universe and in time.&lt;/p&gt;

&lt;p&gt;Light carries some form of energy, the unit of which we measure in Joules. We refer to this energy as radiant energy. The function that measures the amount of energy generated is in terms of the wavelength of the light. (write equation) states that the energy carried by a photon (which we can consider as 1 unit of light) is equal to the speed of light multiplied by Planck’s constant, divided by the wavelength. Planck’s constant is another one of these universal constants. (Talk a bit about Planck’s constant).&lt;/p&gt;

&lt;p&gt;Although energy is transmitted over an amount of time, when we’e rendering, we’re measuring light at one point at a time - and to do so we need to take the differential energy per differential time, the resulting units being joules per second. This value is known as radiant flux, or power. It is the total amount of energy passing through a surface or region of space per unit time.&lt;/p&gt;

&lt;p&gt;Now that we have radiant flux, we need to measure how much flux is arriving at or leaving a particular surface area, per 1 unit of time. This value is known as irradiance, if the area is receiving light, or radiant exitance if it is leaving it. The measurements of this will be W/m^2, we’re taking the differential power per differential area at a point.&lt;/p&gt;

&lt;p&gt;Before we measure radiance, we need to define the idea of a solid angle. We are accustomed to the idea of measuring angles about a point, in 2D, where a full revolution of 360 degrees results in a circle. An extension of this, whereby we define an angle with respect to a plane, results in a sphere covering all the possible angles about a point. We measure planar angles in radians - and the spherical angles in steradians, which is the total area subtended by the object projected on the unit sphere surrounding the point.&lt;/p&gt;

&lt;p&gt;Radiance is the most important radiometric quantity. Whereas irradiance and radiant exitance gave us the differential power per differential area at a point p, the direction was not at all specified.&lt;/p&gt;

&lt;p&gt;In this post we’ll re-visit radiometry. I’ve been re-reading the radiometry chapters from Advanced Global Illumination and PBRT. And I had an 11 hour flight which I felt was the appropriate time to dive into the Veach thesis. For those unfamiliar with the Veach thesis, it’s Eric Veach’s PhD thesis titled Robust Monte Carlo Methods for Light Transport Simulation. It introduces the ideas of Multiple Importance Sampling, Bidirectional Path Tracing and Metropolis Light Transport, and is a must read for anyone interested in rendering and light transport. Dr. Veach does an excellent job of building up the foundational knowledge required to understamd thsese concepts.&lt;/p&gt;

&lt;p&gt;I’ll talk a bit about the radiometric quantities and borrow from many different sources to explain and visualize as best I can each one.&lt;/p&gt;

&lt;p&gt;LOOK AT THE 2D GLOBAL ILLUMINATION PAPER BY JAROSZ.&lt;/p&gt;

&lt;p&gt;The first quantity I’ll describe is the radiant power which is the energy per unit time, measured in watts (joules per second). For example, it’s used to describe how much energy is emitted by some light source. With Q(t) being the function that measures the photonic energy in an area D(t), the function to describe the rate of energy would be the differentiated function of this - dQ(t) / dt  The mathematical notation for the radiant power. In most cases however, we don’t really worry about the energy changing over time, so we can usually leave out this parameter in our notation.&lt;/p&gt;

&lt;p&gt;Irradiance is defined as the power per unit surface area, which would be Watts per meters squared. The irradiance is defined with respect to a point on a surface. The point is our unit surface area. The irradiance is ususally specific to the INCIDENT power per unit surface - if the light is leaving the surface then it is usually referred to as radiant exitance.&lt;/p&gt;

&lt;p&gt;Radiance is is the ratio&lt;/p&gt;

&lt;p&gt;The beast that is the rendering equation attempts to measure the outputted light from a single point. The most common from most people are familiar with is the one below:&lt;/p&gt;

&lt;p&gt;L(x, w_o) is attempting to measure the light outgoing from point x. Light outgoing, however, is a very ambiguous term. I’ll attempt to explain some of the units related to the measuring of light and immediately tie them to the rendering equation.&lt;/p&gt;</content><author><name>Darryl Gouder</name></author><summary type="html">The root concept of all computer graphics is the propogation light, and how we describe and measure its propogration throughout a scene. In the case of physically based rendering, physics is our ground truth, therefore the quantities used to measure light and the ideas on how the light behaves under arbitrary conditions are an attractive and elegant way of simulating light transport. At the root all these physical ideas is radiometry. This is a topic that I initially did not hold as much appreciation as I should have when I first started out in computer graphics, however I’ve come to realize that understanding radiometry well will lead to a more intuitive understanding of many different concepts in PBR. In this blog post, I’ll use various sources to write at length about the different radiometric quantities, with examples and as many visual cues as possible. Light is the visible part of the electromagnetic spectrum and therefor subject to all the ideas that we have regarding the behaviour of electromagnetic radiation. Most of us are familiar with the speed of light, approximately measured at 299,792,458 metres per second in a vacuum. This value is a commonly referred to as c and is part of a special group known as universal constants - a value which is constant both in the universe and in time. Light carries some form of energy, the unit of which we measure in Joules. We refer to this energy as radiant energy. The function that measures the amount of energy generated is in terms of the wavelength of the light. (write equation) states that the energy carried by a photon (which we can consider as 1 unit of light) is equal to the speed of light multiplied by Planck’s constant, divided by the wavelength. Planck’s constant is another one of these universal constants. (Talk a bit about Planck’s constant). Although energy is transmitted over an amount of time, when we’e rendering, we’re measuring light at one point at a time - and to do so we need to take the differential energy per differential time, the resulting units being joules per second. This value is known as radiant flux, or power. It is the total amount of energy passing through a surface or region of space per unit time. Now that we have radiant flux, we need to measure how much flux is arriving at or leaving a particular surface area, per 1 unit of time. This value is known as irradiance, if the area is receiving light, or radiant exitance if it is leaving it. The measurements of this will be W/m^2, we’re taking the differential power per differential area at a point. Before we measure radiance, we need to define the idea of a solid angle. We are accustomed to the idea of measuring angles about a point, in 2D, where a full revolution of 360 degrees results in a circle. An extension of this, whereby we define an angle with respect to a plane, results in a sphere covering all the possible angles about a point. We measure planar angles in radians - and the spherical angles in steradians, which is the total area subtended by the object projected on the unit sphere surrounding the point. Radiance is the most important radiometric quantity. Whereas irradiance and radiant exitance gave us the differential power per differential area at a point p, the direction was not at all specified. In this post we’ll re-visit radiometry. I’ve been re-reading the radiometry chapters from Advanced Global Illumination and PBRT. And I had an 11 hour flight which I felt was the appropriate time to dive into the Veach thesis. For those unfamiliar with the Veach thesis, it’s Eric Veach’s PhD thesis titled Robust Monte Carlo Methods for Light Transport Simulation. It introduces the ideas of Multiple Importance Sampling, Bidirectional Path Tracing and Metropolis Light Transport, and is a must read for anyone interested in rendering and light transport. Dr. Veach does an excellent job of building up the foundational knowledge required to understamd thsese concepts. I’ll talk a bit about the radiometric quantities and borrow from many different sources to explain and visualize as best I can each one. LOOK AT THE 2D GLOBAL ILLUMINATION PAPER BY JAROSZ.</summary></entry><entry><title type="html">Ray Tracing The Rest of Your Life: A reader’s companion, Chapter 1</title><link href="http://localhost:4000/rendering,/mathematics,/monte-carlo/2019/01/07/rt_rc_chapter1/" rel="alternate" type="text/html" title="Ray Tracing The Rest of Your Life: A reader's companion, Chapter 1" /><published>2019-01-07T10:30:00+00:00</published><updated>2019-01-07T10:30:00+00:00</updated><id>http://localhost:4000/rendering,/mathematics,/monte-carlo/2019/01/07/rt_rc_chapter1</id><content type="html" xml:base="http://localhost:4000/rendering,/mathematics,/monte-carlo/2019/01/07/rt_rc_chapter1/">&lt;p&gt;This blog series is a set of notes that expand on Dr Shirley’s “Ray Tracing The Rest of Your Life” book. The book is short and sweet, introducing all the tools that one will need in their arsenal to build a sophisticated ray tracer. I found it very refreshing in terms of simplifying otherwise esoteric concepts and bridging the gap between simple mathematical concepts and how they are used in ray tracing.&lt;/p&gt;

&lt;p&gt;My journey through the book raised many questions, which Dr Shirley was very helpful in answering and explaining. Along the way I read many different articles and saw different videos to understand things. I am probably not the only person who needed help understanding things and won’t be the last, so I thought it would be a good idea to share the information that I gathered.&lt;/p&gt;

&lt;p&gt;The format of this post is unconventional  - you should have a copy of &lt;a href=&quot;http://www.realtimerendering.com/raytracing/Ray%20Tracing_%20the%20Rest%20of%20Your%20Life.pdf&quot; target=&quot;_blank&quot;&gt;the book&lt;/a&gt; (ideally the pdf as it is the most recent updated) open in another tab. I’ll try to guide you as best as I can throughout the book by suggesting to look at the book and come back when you reach a certain point.&lt;/p&gt;
&lt;p align=&quot;center&quot; style=&quot;color:red;&quot;&gt;
&lt;b&gt;These statements will be in bold and red! &lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Re-reading is also very important - it’s very hard to understand everything at a first read. Don’t worry too much if you don’t get everything immediately. These are not straightforward concepts so just keep at it. With all that said, let’s start.&lt;/p&gt;

&lt;h1 id=&quot;chapter-1-a-simple-monte-carlo-program&quot;&gt;Chapter 1: A Simple Monte Carlo Program&lt;/h1&gt;

&lt;p&gt;The first chapter is very straightforward. Demonstrating Monte Carlo by estimating &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt; is a prevalent computational statistics example.&lt;/p&gt;

&lt;p&gt;The code presented in the book very simple and self explanatory. A point is generated inside a square and if it is inside the circle, we increase the variable tracking the points inside the circle. We divide this final count by the total number of points we generate to get an average answer to &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt;.&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;color:red;&quot;&gt;
&lt;b&gt;
It’s time to go look at the book - read up until the you get to the 2nd code snippet, involving the running \(\pi\) calculation program.
&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;One of the questions of those uninitiated in probability and Monte Carlo theory might be: How does this type of computation work and why give us an estimate of &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt;? This stems from what is known as the &lt;strong&gt;expected value&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;A classic example in explaining the expected value is trying to answer the question:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
What is the probability that I will get a heads, when I flip a fair coin?
&lt;/p&gt;

&lt;p&gt;We know intuitively that it is 0.5. However what the expected value theory shows us is that if we&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;get an actual fair coin,&lt;/li&gt;
  &lt;li&gt;start flipping it,&lt;/li&gt;
  &lt;li&gt;take note of each result,&lt;/li&gt;
  &lt;li&gt;count the number of heads and tails,&lt;/li&gt;
  &lt;li&gt;average them,&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We will probably get a result close to 0.5. The more times we toss the coin, the closer to 0.5 the answer will be.&lt;/p&gt;

&lt;p&gt;The mathematical notation used to describe the expected value is:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E[X] = \sum_{i=1}^k x_i p_i = x_1 p_1 + x_2 p_2 + ... + x_k p_k&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;E[X]&lt;/script&gt; is the expected value of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;, our statistical experiment.&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;x_i&lt;/script&gt; is the result of each sample that we compute of our function&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;p_i&lt;/script&gt; is the probability weight of this sample.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The reason why this works is a theorem known as the &lt;strong&gt;Law of Large Numbers&lt;/strong&gt;. The weak law of large numbers states that if we take a number of samples and average them, it will &lt;em&gt;PROBABLY&lt;/em&gt; converge to the expected value. The strong law of large numbers states that it will converge &lt;em&gt;ALMOST SURELY&lt;/em&gt; (with probability 1). We’re not going to go down this rabbit hole, the one of interest to us in the weak law.&lt;/p&gt;

&lt;p&gt;An important term that we should define is &lt;strong&gt;variance&lt;/strong&gt;. In our example, we were trying to compute &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt;, which makes this  the mean we’re trying to estimate. The variance, in very informal language, measures how spread out our sample computations are from this mean. The lower the variance, the less spread out the samples are and the more accurate our computed mean is to the expected value (the expected value is also known as the mean). If we have high variance, this means our samples are spread out, and we might be using an ineffective function to computationally find our mean.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;Law of Diminishing Returns&lt;/strong&gt; explains the idea that the more samples we take, the more we need than before, to get an accurate answer.  In terms of numbers, if you want to half the error that you’re getting, you’ll need to quadruple the amount of samples. Here is how the error between our estimated value of &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt; and actual &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt; decreases as we compute more samples.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/posts/rt_rc_chapter1/pi_estimate.png&quot; alt=&quot; $$ \pi $$ Estimate error&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;This doesn’t hold a lot of significance for now but it’s good to keep this in mind.&lt;/p&gt;

&lt;p align=&quot;center&quot; style=&quot;color:red;&quot;&gt;
&lt;b&gt;Now would be a good time to go read the rest of the chapter.&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;Stratification is a way of intelligently placing your samples to estimate your function better. If you look at my blog post about random numbers, I show that a good PRNG (Pseudo-random number generator) should generate uniformly distributed points. However to ensure true uniformity, without having clustered samples, we stratify the samples we take.&lt;/p&gt;

&lt;p&gt;The careful selection of samples to minimize variance is an ongoing area of research, that is an absolutely fascinating subject and one of my favourite topics in CG. Dr. Shirley expands a bit on this is in this blog post: &lt;a href=&quot;http://psgraphics.blogspot.com/2018/10/flavors-of-sampling-in-ray-tracing.html&quot; target=&quot;_blank&quot;&gt;Flavors of sampling in ray tracing&lt;/a&gt;.
Some more links from me about this topic. I’ll re-visit this at the end of Chapter 2, once we define the Monte Carlo Integral.&lt;/p&gt;

&lt;p&gt;The next post will be on Chapter 2, where I’ll delve a bit more into Monte Carlo theory and we’ll start performing some more interesting computations.&lt;/p&gt;

&lt;p&gt;If you have any questions and feedback, feel free to comment or contact me via twitter/email.&lt;/p&gt;</content><author><name>Darryl Gouder</name></author><summary type="html">This blog series is a set of notes that expand on Dr Shirley’s “Ray Tracing The Rest of Your Life” book. The book is short and sweet, introducing all the tools that one will need in their arsenal to build a sophisticated ray tracer. I found it very refreshing in terms of simplifying otherwise esoteric concepts and bridging the gap between simple mathematical concepts and how they are used in ray tracing. My journey through the book raised many questions, which Dr Shirley was very helpful in answering and explaining. Along the way I read many different articles and saw different videos to understand things. I am probably not the only person who needed help understanding things and won’t be the last, so I thought it would be a good idea to share the information that I gathered. The format of this post is unconventional - you should have a copy of the book (ideally the pdf as it is the most recent updated) open in another tab. I’ll try to guide you as best as I can throughout the book by suggesting to look at the book and come back when you reach a certain point. These statements will be in bold and red! Re-reading is also very important - it’s very hard to understand everything at a first read. Don’t worry too much if you don’t get everything immediately. These are not straightforward concepts so just keep at it. With all that said, let’s start. Chapter 1: A Simple Monte Carlo Program The first chapter is very straightforward. Demonstrating Monte Carlo by estimating is a prevalent computational statistics example. The code presented in the book very simple and self explanatory. A point is generated inside a square and if it is inside the circle, we increase the variable tracking the points inside the circle. We divide this final count by the total number of points we generate to get an average answer to . It’s time to go look at the book - read up until the you get to the 2nd code snippet, involving the running \(\pi\) calculation program. One of the questions of those uninitiated in probability and Monte Carlo theory might be: How does this type of computation work and why give us an estimate of ? This stems from what is known as the expected value. A classic example in explaining the expected value is trying to answer the question: What is the probability that I will get a heads, when I flip a fair coin? We know intuitively that it is 0.5. However what the expected value theory shows us is that if we get an actual fair coin, start flipping it, take note of each result, count the number of heads and tails, average them, We will probably get a result close to 0.5. The more times we toss the coin, the closer to 0.5 the answer will be. The mathematical notation used to describe the expected value is: is the expected value of , our statistical experiment. is the result of each sample that we compute of our function is the probability weight of this sample. The reason why this works is a theorem known as the Law of Large Numbers. The weak law of large numbers states that if we take a number of samples and average them, it will PROBABLY converge to the expected value. The strong law of large numbers states that it will converge ALMOST SURELY (with probability 1). We’re not going to go down this rabbit hole, the one of interest to us in the weak law. An important term that we should define is variance. In our example, we were trying to compute , which makes this the mean we’re trying to estimate. The variance, in very informal language, measures how spread out our sample computations are from this mean. The lower the variance, the less spread out the samples are and the more accurate our computed mean is to the expected value (the expected value is also known as the mean). If we have high variance, this means our samples are spread out, and we might be using an ineffective function to computationally find our mean. The Law of Diminishing Returns explains the idea that the more samples we take, the more we need than before, to get an accurate answer. In terms of numbers, if you want to half the error that you’re getting, you’ll need to quadruple the amount of samples. Here is how the error between our estimated value of and actual decreases as we compute more samples. This doesn’t hold a lot of significance for now but it’s good to keep this in mind. Now would be a good time to go read the rest of the chapter. Stratification is a way of intelligently placing your samples to estimate your function better. If you look at my blog post about random numbers, I show that a good PRNG (Pseudo-random number generator) should generate uniformly distributed points. However to ensure true uniformity, without having clustered samples, we stratify the samples we take. The careful selection of samples to minimize variance is an ongoing area of research, that is an absolutely fascinating subject and one of my favourite topics in CG. Dr. Shirley expands a bit on this is in this blog post: Flavors of sampling in ray tracing. Some more links from me about this topic. I’ll re-visit this at the end of Chapter 2, once we define the Monte Carlo Integral.</summary></entry><entry><title type="html">Pseudo Random Number Generation</title><link href="http://localhost:4000/mathematics,/monte-carlo/2018/07/04/prngs/" rel="alternate" type="text/html" title="Pseudo Random Number Generation" /><published>2018-07-04T10:30:00+01:00</published><updated>2018-07-04T10:30:00+01:00</updated><id>http://localhost:4000/mathematics,/monte-carlo/2018/07/04/prngs</id><content type="html" xml:base="http://localhost:4000/mathematics,/monte-carlo/2018/07/04/prngs/">&lt;p&gt;In this post I’ll talk a bit about pseudo random number generation. This will be the first in an assortment of posts regarding monte carlo methods.&lt;/p&gt;

&lt;p&gt;I’ll assume you have working knowledge of calculus and some probability and statistics.&lt;/p&gt;

&lt;p&gt;The most essential aspect of any form of monte carlo method is the generation of random numbers. Uniformly distributed random numbers on the interval [0,1] are what we’d like to generate first, as they are also what is required for the other types of distributions.&lt;/p&gt;

&lt;p&gt;Generating random numbers using a pseudo random number generator (PRNG) means that we generate a sequence of numbers, using some particular seed value (some arbitrary constant) that initializes the random number generation algorithm. We use the term pseudo, because the numbers generated are not truly random but generated deterministically and hence can be replicated if the same seed and the same constants in the function are used. This is ideal for us, so that we can replicate and debug our algorithms. We can think of these algorithms as generating a deterministic sequence which is based on a starting point.&lt;/p&gt;

&lt;p&gt;For this sequence to be considered to be of good quality, it should have certain properties, such as lack of predictibility (i.e. if we generate x values, and we can guess the next, this means the predctibility is possible) and equidistribution. For example if the mean of a large sequence of uniformly distributed numbers in the range [0,1] is not 0.5, then it is likely that something is wrong with the PRNG, given that due to the Law of Large Numbers, we would expect the arithmetic mean of this sequence to be similar to the expected mean (the expected mean being 0.5). We won’t focus on hardcore evaluation PRNGs and leave that to other minds, some useful links are &lt;a href=&quot;http://pit-claudel.fr/clement/blog/how-random-is-pseudo-random-testing-pseudo-random-number-generators-and-measuring-randomness/&quot; target=&quot;_blank&quot;&gt;“How random is pseudorandom testing pseudorandom number generators and measuring randomness”&lt;/a&gt; and &lt;a href=&quot;http://simul.iro.umontreal.ca/testu01/tu01.html&quot; target=&quot;_blank&quot;&gt;TestU01 tests&lt;/a&gt;. We’ll look at 2 PRNGs and do some simple tests to measure their quality.&lt;/p&gt;

&lt;p&gt;Let’s look at a simple PRNG known as the Linear Congruential Generator (which I’ll now continue referring to as LCG).&lt;/p&gt;

&lt;p&gt;The LCG is an easy-to-implement PRNG, the function definition being:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://latex.codecogs.com/gif.latex?X_{n&amp;plus;1}=&amp;space;(a&amp;space;*&amp;space;X_n&amp;space;&amp;plus;&amp;space;c)&amp;space;\bmod&amp;space;m&quot; title=&quot;X_{n+1}= (a * X_n + c) \bmod m&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;where:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;m&lt;/strong&gt; is the modulus constant, and &lt;strong&gt;m&lt;/strong&gt; &amp;gt; 0.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;a&lt;/strong&gt; is the multiplier, and 0 &amp;lt; &lt;strong&gt;a&lt;/strong&gt; &amp;lt; &lt;strong&gt;m&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;c&lt;/strong&gt; is the increment, 0 &amp;lt;= &lt;strong&gt;c&lt;/strong&gt; &amp;lt;= &lt;strong&gt;m&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt; is the seed value, 0 &amp;lt;= &lt;strong&gt;X&lt;/strong&gt;&lt;sub&gt;0&lt;/sub&gt; &amp;lt; &lt;strong&gt;m&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The above constants are all integers. Careful selection of these values ensures that the sequence we get is of a high quality.&lt;/p&gt;

&lt;p&gt;Here’s an R listing of what the code for this should look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;&lt;span class=&quot;n&quot;&gt;lcgen&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1229&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2048&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;+1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;+1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;N is the number of random numbers we want to generate. Let’s generate 1000 samples and plot a histogram to look at the distribution.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/prngs/lcg_histogram.png&quot; alt=&quot;LCG histogr§am&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;It’s fair to say, the distribution of samples looks good. Given that the generation of a value is dependent on the next let’s see if we can see a pattern by plotting them in a time series.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/prngs/lcg_time_series.png&quot; alt=&quot;LCG Time Series&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;That looks pretty random, so let’s plot them in series, taking pairs as cartesian coordinates (x_2k-1, x_2k). This type of test is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Autocorrelation&quot; target=&quot;_blank&quot;&gt;autocorrelation&lt;/a&gt;.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/prngs/lcg_2d.png&quot; alt=&quot;LCG 2D Autocorrelation&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Well that’s interesting, pairs line up as lines… what if we plot them in 3D?&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/prngs/lcg_3d.gif&quot; alt=&quot;LCG 3D Autocorrelation&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;The numbers are forming a line in 2D, a plane in 3D and this pattern continues in n-dimensions, where a n-dimensional hyperplane is formed for the n’th dimension. George Marsaglia identified this issue in 1968 and it is now know as the Marsaglia Theorem. He pointed out the worrying conclusion that all the papers that had used a LCG as their PRNG of choice might have wrong results. This highlights the importance of using a good PRNG.&lt;/p&gt;

&lt;p&gt;From now on we’ll use a PRNG of a higher quality, the Mersenne Twister. I won’t go into its implementation, it’s a lot more sophisticated and robust than the LCG. The more recent &lt;a href=&quot;http://www.pcg-random.org/&quot; target=&quot;_blank&quot;&gt;PCG PRNG&lt;/a&gt; is better than Mersenne and it’s what I use in my rendering system. Having said that, R’s runif (short for random uniform) command uses the Mersenne Twister algorithm, and for these posts it should suffice. PBRT 2 used to use Mersenne Twister and PBRT V3 uses PCG.&lt;/p&gt;

&lt;p&gt;If we re-run the above tests using Mersenne Twister, we can see that, the histogram looks acceptable,&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/prngs/mersenne_hist.png&quot; alt=&quot;Mersenne Histogram&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;so does the time series plot,&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/prngs/mersenne_time_series.png&quot; alt=&quot;Mersenne Time Series&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;and the 2D plot (points look to be well distributed in the 2D plane)&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/prngs/mersenne_2d.png&quot; alt=&quot;Mersenne 2D Autocorrelation&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;and the 3D plot (points look to be well distributed in the 3D unit cube).&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/prngs/mersenne_3d.gif&quot; alt=&quot;Mersenne 3D Autocorrelation&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Whenever you see runif, assume the numbers are well uniformly-distributed using the Mersenne Twister algorithm. Now that we’ve understood a bit more how uniform random numbers are generated, I’ll later post about transforming these uniform random numbers into other forms of distributions, e.g. normally distributed.&lt;/p&gt;</content><author><name>Darryl Gouder</name></author><summary type="html">In this post I’ll talk a bit about pseudo random number generation. This will be the first in an assortment of posts regarding monte carlo methods. I’ll assume you have working knowledge of calculus and some probability and statistics. The most essential aspect of any form of monte carlo method is the generation of random numbers. Uniformly distributed random numbers on the interval [0,1] are what we’d like to generate first, as they are also what is required for the other types of distributions. Generating random numbers using a pseudo random number generator (PRNG) means that we generate a sequence of numbers, using some particular seed value (some arbitrary constant) that initializes the random number generation algorithm. We use the term pseudo, because the numbers generated are not truly random but generated deterministically and hence can be replicated if the same seed and the same constants in the function are used. This is ideal for us, so that we can replicate and debug our algorithms. We can think of these algorithms as generating a deterministic sequence which is based on a starting point. For this sequence to be considered to be of good quality, it should have certain properties, such as lack of predictibility (i.e. if we generate x values, and we can guess the next, this means the predctibility is possible) and equidistribution. For example if the mean of a large sequence of uniformly distributed numbers in the range [0,1] is not 0.5, then it is likely that something is wrong with the PRNG, given that due to the Law of Large Numbers, we would expect the arithmetic mean of this sequence to be similar to the expected mean (the expected mean being 0.5). We won’t focus on hardcore evaluation PRNGs and leave that to other minds, some useful links are “How random is pseudorandom testing pseudorandom number generators and measuring randomness” and TestU01 tests. We’ll look at 2 PRNGs and do some simple tests to measure their quality. Let’s look at a simple PRNG known as the Linear Congruential Generator (which I’ll now continue referring to as LCG). The LCG is an easy-to-implement PRNG, the function definition being: where: m is the modulus constant, and m &amp;gt; 0. a is the multiplier, and 0 &amp;lt; a &amp;lt; m. c is the increment, 0 &amp;lt;= c &amp;lt;= m. X0 is the seed value, 0 &amp;lt;= X0 &amp;lt; m. The above constants are all integers. Careful selection of these values ensures that the sequence we get is of a high quality. Here’s an R listing of what the code for this should look like: lcgen &amp;lt;- function(x0=4, N, a=1229, c=1, m=2048) { x = c() x[1] = x0 for(n in 2:(N+1)) { x[n] = (a * x[n-1] + c) %% m } return (x[2:(N+1)]/m) } N is the number of random numbers we want to generate. Let’s generate 1000 samples and plot a histogram to look at the distribution.</summary></entry><entry><title type="html">Hello embree</title><link href="http://localhost:4000/rendering,/graphics/2018/05/27/hello-embree/" rel="alternate" type="text/html" title="Hello embree" /><published>2018-05-27T10:30:00+01:00</published><updated>2018-05-27T10:30:00+01:00</updated><id>http://localhost:4000/rendering,/graphics/2018/05/27/hello-embree</id><content type="html" xml:base="http://localhost:4000/rendering,/graphics/2018/05/27/hello-embree/">&lt;p&gt;I’ve been slowly developing a raytracer which has been a lot of fun and a great learning experience both from a technical standpoint and the theoretical side of physically-based rendering.&lt;/p&gt;

&lt;p&gt;I’m at a point now where I am importing meshes of a larger nature, and I was not content with my BVH implementation. As much as I would like to read the state of the art papers on BVH construction and traversal and implement them myself, I’ve decided to opt to use embree instead. I would rather focus on the light transport part and focus on getting prettier images and getting them to converge quicker from an algorithmic standpoint. As a friend of mine said, I have to pick my battles, and embree is going to do a lot of heavy lifting for me so that I can focus more on what I’d like to write.&lt;/p&gt;

&lt;p&gt;Setting up embree with CMake is quite easy &lt;a href=&quot;https://bitbucket.org/dgouder/embree-renderer/src/master/&quot; target=&quot;_blank&quot;&gt;I’ve got the full source code of this post available here&lt;/a&gt;	, and I won’t go into details into how to set it up - the CMakeLists.txt is quite self explanatory and I’ve added as much comments as I can.&lt;/p&gt;

&lt;p&gt;As great and as fleshed out the samples are, there is a lot of boilerplate code, written in different header files. This put me off initially but with a bit of digging, and building the samples with a powerful IDE went long way in help way in helping me zip around the API and the headers.&lt;/p&gt;

&lt;p&gt;I thought it would be interesting to write the simplest thing I can think of with embree, a hello world ray tracing example if you will, I’ll explain below what we’ll do.&lt;/p&gt;

&lt;h3 id=&quot;what-is-embree&quot;&gt;What is embree?&lt;/h3&gt;

&lt;p&gt;Embree is a high-performance ray tracing kernel library written by Intel. It contains state-of-the-art implementations of acceleration structure and intersection methods, and provide a plethora of features to write a performant ray tracer. More details can be found here, and in their white paper. They target the Intel architecture specifically and are highly optimized using SIMD intrinsics to push as much as performance as possible.&lt;/p&gt;

&lt;h3 id=&quot;hello-embree&quot;&gt;Hello Embree!&lt;/h3&gt;

&lt;p&gt;My toy example shoots a ray per pixel and returns white if nothing is hit and black if the triangle places in the centre of the image is hit. This is the main function:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Inititiate device and scene
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Add geometry to scene
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Initiate image parameters, image and camera
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Render image
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Output image
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Release scene
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll work through each of these with a short explanation for everything. The full source code listing can be found here. It is self contained, with embree being part of the sources. If you have any issues with compilation, feel free to contact me.&lt;/p&gt;

&lt;p&gt;If you want to skip ahead:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#device-initiation&quot;&gt;Device initiation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#adding-geometry-to-the-scene&quot;&gt;Adding geometry to the scene&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#creating-the-triangle-geometry-and-defining-the-vertices&quot;&gt;Creating the triangle geometry and defining the vertices&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#render-image&quot;&gt;Render image&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#output-image&quot;&gt;Output image&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#release-scene&quot;&gt;Release scene&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;device-initiation&quot;&gt;Device initiation&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Inititiate device and scene
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RTCDevice&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rtcNewDevice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RTCScene&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rtcNewScene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The device object is defined to be a class factory for all the other objects that we’ll be creating such as the scene and the geometry, using the &lt;a href=&quot;https://embree.github.io/api.html#rtcnewdevice&quot; target=&quot;_blank&quot;&gt;rtcNewDevice&lt;/a&gt; call. The device handle is not destroyed until all objects bound with the device are released. Embree uses reference counting to keep track of the lifetime of all the objects you create - functions with the word release decrease the reference counter. It’s very important to use the release functions, otherwise you’re leaking memory. I’ve heard that for every byte of leaked memory, a kitten drowns and we don’t want that now do we?&lt;/p&gt;

&lt;p&gt;The new scene is created and bound to the device previously created.&lt;/p&gt;

&lt;h3 id=&quot;adding-geometry-to-the-scene&quot;&gt;Adding geometry to the scene&lt;/h3&gt;

&lt;p&gt;We now need to define and add the geometry to our scene. I’m just going to create a triangle in the middle of the screen.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Create a new geometry for the triangle
// Define the vertices
// Assign the vertices to the geometry buffer 
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Commit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;geometry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;creating-the-triangle-geometry-and-defining-the-vertices&quot;&gt;Creating the triangle geometry and defining the vertices&lt;/h4&gt;

&lt;p&gt;We’ll need to allocate memory for our geometry:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Create a new geometry for the triangle
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RTCGeometry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rtcNewGeometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTC_GEOMETRY_TYPE_TRIANGLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Vertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rtcSetNewGeometryBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTC_BUFFER_TYPE_VERTEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTC_FORMAT_FLOAT3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We create a geometry object using &lt;a href=&quot;https://embree.github.io/api.html#rtcnewgeometry&quot;&gt;rtcNewGeometry&lt;/a&gt;, which is attached to our device and we’ve picked a triangle to be our geometry of choice. Embree has a selection of different geometry types available, which you can find inside the documenation. Once we’ve created our geometry object, we create a buffer for the vertices, using &lt;a href=&quot;https://embree.github.io/api.html#rtcsetnewgeometrybuffer&quot;&gt;rtcSetNewGeometryBuffer&lt;/a&gt;. We’ll use this function to set the indices later on. The key here is the second parameter, RTC_BUFFER_TYPE_VERTEX.&lt;/p&gt;

&lt;p&gt;Next is the vertices:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Define the vertices
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Nothing extraordinary here - just defining the positions of the vertices. We’ll now assign these indices to our buffer:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Assign the vertices to the geometry buffer
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Triangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;triangles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Triangle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rtcSetNewGeometryBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTC_BUFFER_TYPE_INDEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTC_FORMAT_UINT3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Triangle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;triangles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;triangles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;triangles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’re now setting up an index buffer for the vertices. Looking at this from a birds eye view, it’s quite similar to how things are done in OpenGL. We’re not done yet though. We need to commit the geometry and the scene.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Commit geometry to the scene
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rtcCommitGeometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;geomID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rtcAttachGeometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rtcReleaseGeometry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rtcCommitScene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So what does this all mean? The &lt;a href=&quot;https://embree.github.io/api.html#rtccommitgeometry&quot; target=&quot;_blank&quot;&gt;rtcCommitGeometry&lt;/a&gt; call commits all the modifications to the geometry and has to be called each time we modify the geometry.&lt;/p&gt;

&lt;p&gt;We then attach the geometry to the scene using &lt;a href=&quot;https://embree.github.io/api.html#rtcattachgeometry&quot; target=&quot;_blank&quot;&gt;rtcAttachGeometry&lt;/a&gt;. The &lt;a href=&quot;https://embree.github.io/api.html#rtcreleasegeometry&quot; target=&quot;_blank&quot;&gt;rtcReleaseGeometry&lt;/a&gt; call decreases the reference count of each piece of geometry. I was quite curious when I saw this and I think it’s because rtcAttachGeometry increase a reference to the mesh by the scene, so the original mesh handle can be disposed of. To commit our scene we’ll need to call rtcCommitScene which builds our spatial data structure. Everytime we modify the geometry, we need to go through this step. We can commit to the scene all once though, as you’ll not might notice in my actual source code that the commit is right after the call to the function that defines the geometry. You can define and commit all your geometry at once and then have a single called right after these definitions.&lt;/p&gt;

&lt;p&gt;We’ll initiate the image and the camera parameters.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Initiate image parameters, image and camera
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;600&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vec3fa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lower_left_corner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vec3fa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;horizontal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vec3fa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertical&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vec3fa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;origin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you’re not familiar with regards to the parameters of the camera, I’d suggest reading up on primary ray generation and the camera model. I might do a post about this later as I used to struggle with this a while back. Now that I’ve said this in public I’ll be forced to do it :)&lt;/p&gt;

&lt;p&gt;Nothing too fancy here, just define the image parameters and the camera parameters for the primary ray generation.&lt;/p&gt;

&lt;p&gt;The next part is where we get to test the ray intersection!&lt;/p&gt;

&lt;h3 id=&quot;render-image&quot;&gt;Render image&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Render image
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Initiate pixel colour
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vec3fa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vec3fa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Create ray intersection context
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// Generate ray
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// Perform ray intersection
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// Check if ray intersected any geometry
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// Set pixel colour
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We’ll now define the intersection context:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Create ray intersection context
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RTCIntersectContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rtcInitIntersectContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We use the RTCIntersectContext for your ray intersection test. &lt;a href=&quot;https://embree.github.io/api.html#rtcinitintersectcontext&quot; target=&quot;_blank&quot;&gt;rtcInitIntersectContext&lt;/a&gt; takes flags which can optimize the performance of the ray tracer, such as indicating that the rays are coherent.&lt;/p&gt;

&lt;p&gt;This is the primary ray generation stolen from Dr. Shirley’s Ray Tracing in One Weekend book.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Generate ray
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vec3fa&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lower_left_corner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;horizontal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertical&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Ray&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;origin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once we have the ray set up, all we need to do is perform a ray intersection test using an embree function suited for &lt;a href=&quot;https://embree.github.io/api.html#rtcintersect1&quot; target=&quot;_blank&quot;&gt;single ray intersection tests&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Perform ray intersection
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rtcIntersect1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTCRayHit_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We need to pass in the scene and the context. The RTCRayHit_ function constructs the embree ray-type from the one that type that we defined ourselves. In reality our ray is very similar to what’s the defined in embree. The intersection information is stored in the ray, and checked:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Check if ray intersected any geometry
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;geomID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTC_INVALID_GEOMETRY_ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;embree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vec3fa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and that’s it! The embree specific stuff ends here. I haven’t included the ray definition and the auxiliary functions to convert because they’re one liners and you can have a poke around in the repo. We then set the colour of the pixel:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Set pixel colour
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and repeat the whole process for each pixel. When that’s done, we spit out our png:&lt;/p&gt;

&lt;h3 id=&quot;output-image&quot;&gt;Output image&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Output image
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lodepng&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello.png&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;encoder error &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lodepng_error_text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’m using lodepng to write the image to file, nothing too complex going on here, and then we get this!&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://localhost:4000/assets/hello-embree/hello.png&quot; alt=&quot;Hello embree&quot; /&gt;
&lt;/p&gt;

&lt;h3 id=&quot;release-scene&quot;&gt;Release scene&lt;/h3&gt;

&lt;p&gt;Now we should clean up after ourselves and leave no memory leaks&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Release the scene
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rtcReleaseScene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and that’s pretty much it.&lt;/p&gt;

&lt;p&gt;Thanks for reading, I know this was quite verbose but I hope it was helpful. Embree’s extensive features means that it’s now significantly easier to write a high-performant ray tracer. I’m very excited in doing more fleshed out examples and melding it with my own ray tracer. I will have to probably change a lot from an architectural standpoint but the performance gains warrant it. If you have any questions feel free to ask, I may not necessarily know the answer but learning is part of the fun and will do what I can to help :)&lt;/p&gt;</content><author><name>Darryl Gouder</name></author><summary type="html">I’ve been slowly developing a raytracer which has been a lot of fun and a great learning experience both from a technical standpoint and the theoretical side of physically-based rendering. I’m at a point now where I am importing meshes of a larger nature, and I was not content with my BVH implementation. As much as I would like to read the state of the art papers on BVH construction and traversal and implement them myself, I’ve decided to opt to use embree instead. I would rather focus on the light transport part and focus on getting prettier images and getting them to converge quicker from an algorithmic standpoint. As a friend of mine said, I have to pick my battles, and embree is going to do a lot of heavy lifting for me so that I can focus more on what I’d like to write. Setting up embree with CMake is quite easy I’ve got the full source code of this post available here , and I won’t go into details into how to set it up - the CMakeLists.txt is quite self explanatory and I’ve added as much comments as I can. As great and as fleshed out the samples are, there is a lot of boilerplate code, written in different header files. This put me off initially but with a bit of digging, and building the samples with a powerful IDE went long way in help way in helping me zip around the API and the headers. I thought it would be interesting to write the simplest thing I can think of with embree, a hello world ray tracing example if you will, I’ll explain below what we’ll do.</summary></entry></feed>