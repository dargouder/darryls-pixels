<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta charset="utf-8">
<meta name="author" content="Darryl Gouder">
<meta name="description" content="Blog about code and stuff...">
<title> Home › Darryl's Pixels</title>
<link rel="canonical" href="http://localhost:4000/page3/">
<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,300italic,400italic" rel="stylesheet">
<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link href="/basic.css" rel="stylesheet">
<link href="/highlight.css" rel="stylesheet">
<link href="/index.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Darryl's Pixels" />


<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<header>
  <h1><a href="">Darryl's Pixels</a></h1>
  <nav>
    <div><a href="/">Home</a><a href="/archive/">Archive</a><a href="/about/">About</a><a href="/solstice/">Solstice</a></div>
    <div><a href="https://twitter.com/dargouder"><i class="fa fa-twitter"></i></a><a href="https://github.com/dargouder"><i class="fa fa-github"></i></a><a href="mailto:dargouder@gmail.com"><i class="fa fa-envelope"></i></a></div>
  </nav>
</header>
<main>
  
  <article>
    <header>
      <h1><a href="/rendering/2019/02/15/rt_rc_chapter1/">Ray Tracing The Rest of Your Life: A reader's companion, Chapter 1</a></h1>
      <time datetime="2019-02-15T00:00:00+01:00">February 15, 2019</time>
    </header>
<p>This blog series is a set of notes that expand on Dr Shirley’s “Ray Tracing The Rest of Your Life” book. The book is compact, introducing all the tools that one will need in their arsenal to build a sophisticated ray tracer. I found it very refreshing in terms of simplifying otherwise esoteric concepts and bridging the gap between simple mathematical concepts and their application in ray tracing.</p>

<p>My journey through the book raised many questions, which Dr Shirley was very helpful in answering and explaining. Along the way I read many different articles and saw different videos to understand things. I am probably not the only person who needed help understanding things and won’t be the last, so I thought it would be a good idea to share the information that I gathered.</p>

<p>The format of this post is unconventional  - you should have a copy of <a href="http://www.realtimerendering.com/raytracing/Ray%20Tracing_%20the%20Rest%20of%20Your%20Life.pdf" target="_blank">the book</a> (ideally the PDF as it is the most recent updated) open in another tab. I’ll try to guide you as best as I can throughout the book by asking you to look at the book and come back when you reach a certain point.</p>
<p align="center" style="color:red;">
<b>These statements will be in bold and red! </b></p>

<p>Re-reading is also very important - it’s very hard to understand everything at a first read. Don’t worry too much if you don’t get everything immediately. These are not straightforward concepts so just keep at it. If you feel truly stuck, reach out to me and we’ll try to clear things up. With all that said, let’s start.</p>

<h1 id="chapter-1-a-simple-monte-carlo-program">Chapter 1: A Simple Monte Carlo Program</h1>

<p>The first chapter is very straightforward. Demonstrating Monte Carlo by estimating <script type="math/tex">\pi</script> is a prevalent computational statistics example.</p>

<p>The code snippet for this that is presented in the book is very simple and self explanatory. A point is generated inside a square and if it is inside the circle, we increase the counter tracking the number of points inside the circle. We divide this final count by the total number of points we generate to get an average answer to <script type="math/tex">\pi</script>.</p>

<p align="center" style="color:red;">
<b>
It’s time to go look at the book - read up until the you get to the 2nd code snippet, involving the running \(\pi\) calculation program.
</b>
</p>

<p>One of the questions of those uninitiated in probability and Monte Carlo theory might be: How does this type of computation work and how does it end up giving us an estimate of <script type="math/tex">\pi</script>? This stems from what is known as the <strong>expected value</strong>.</p>

<p>A classic example in explaining the expected value is trying to answer the question:</p>

<p align="center">
What is the probability that I will get a heads, when I flip a fair coin?
</p>

<p>We know intuitively that it is 0.5. However what the expected value theory shows us is that if we</p>

<ol>
  <li>get an actual fair coin,</li>
  <li>start flipping it,</li>
  <li>take note of each result,</li>
  <li>count the number of heads and tails,</li>
  <li>average them,</li>
</ol>

<p>We will probably get a result close to 0.5. The more times we toss the coin, the closer to 0.5 the answer will be.</p>

<p>The mathematical notation used to describe the expected value is:</p>

<script type="math/tex; mode=display">E[X] = \sum_{i=1}^k x_i p_i = x_1 p_1 + x_2 p_2 + ... + x_k p_k</script>

<ul>
  <li><script type="math/tex">E[X]</script> is the expected value of <script type="math/tex">X</script>, our statistical experiment.</li>
  <li><script type="math/tex">x_i</script> is the result of each sample that we compute of our function</li>
  <li><script type="math/tex">p_i</script> is the probability weight of this sample. They must sum up to 1.</li>
</ul>

<p>I’ll use another example rather than a coin toss to tie with the above equation. If we had a fair 6-sided dice, the expected value would be:</p>

<script type="math/tex; mode=display">E[X] = \sum_{i=1}^k x_i p_i = \frac{1}{6} + \frac{2}{6} + \frac{3}{6} +  \frac{4}{6} + \frac{5}{6} + \frac{6}{6} = 3.5</script>

<p>where <script type="math/tex">x_i</script> was the dice roll and $$ \frac{1}{6} was the probability weight. If dice wasn’t fair, the weights would be different - that doesn’t matter as long as they sum up to one.</p>

<p>Back to our original monte carlo example, the reason why this works is a theorem known as the <strong>Law of Large Numbers</strong>. The weak law of large numbers states that if we take a number of samples and average them, it will <em>PROBABLY</em> converge to the expected value. The strong law of large numbers states that it will converge <em>ALMOST SURELY</em> (with probability 1). We’re not going to go down this rabbit hole, the one of interest to us in the weak law.</p>

<p>An important term that we should define is <strong>variance</strong>. In our example, we were trying to compute <script type="math/tex">\pi</script>, which makes this  the mean we’re trying to estimate. The variance, in very informal language, measures how spread out our sample computations are from this mean. The lower the variance, the less spread out the samples are and the more accurate our computed mean is to the expected value (the expected value is also known as the mean). If we have high variance, this means our samples are spread out, and we might be using an ineffective function to computationally find our mean. There are ways to quantify variance which are useful for estimating the error of our Monte Carlo techniques, however I think it would not be fruitful for now to discuss those.</p>

<p>The <strong>Law of Diminishing Returns</strong> explains the idea that the more samples we take, the more we need than before, to get an accurate answer.  In terms of numbers, if you want to half the error that you’re getting, you’ll need to quadruple the amount of samples. Here is how the error between our estimated value of <script type="math/tex">\pi</script> and actual <script type="math/tex">\pi</script> decreases as we compute more samples.</p>

<p align="center">
<img src="http://localhost:4000/assets/posts/rt_rc_chapter1/pi_estimate.png" alt=" $$ \pi $$ Estimate error" />
</p>

<p>Notice how after sample 200, the error doesn’t decrease that much. This doesn’t hold a lot of significance for now but it’s good to keep this in mind.</p>

<p align="center" style="color:red;">
<b>Now would be a good time to go read the rest of the chapter.</b>
</p>

<p>Stratification is a way of intelligently placing your samples to estimate your function better. If you look at my <a href="https://dargouder.github.io/darryls-pixels/mathematics/2018/07/04/prngs/" target="_blank">blog post</a> about random numbers, I show that a good PRNG (Pseudo-Random Number Generator) should generate uniformly distributed points. When you’re dealing with multiple dimensions a PRNG’s inherent randomness isn’t enough. Think of dimensions this way: you need 2 uniform random numbers for your primary ray, then 2 for your lens, then another 2 for your next bounce and so forth. Everytime, you’re adding another dimension and although your random numbers are unifornm if we look at them at being in the same dimension, it may not necessarily be the case when used in these different dimensions. To ensure true uniformity, without having clustered samples, we stratify the samples we take.</p>

<p>The careful selection of samples to minimize variance is an ongoing area of research, that is an absolutely fascinating subject and one of my favourite topics in CG. Dr. Shirley expands on this topic is in this blog post: <a href="http://psgraphics.blogspot.com/2018/10/flavors-of-sampling-in-ray-tracing.html" target="_blank">Flavors of sampling in ray tracing</a>. Leonhard Grünschloß has some excellent implementations of different <a href="http://gruenschloss.org/" target="_blank">Quasi-Monte Carlo based samplers</a>.</p>

<p>I’ll slightly re-visit stratification at the end of Chapter 2, once we define the Monte Carlo Integral and importance sampling. The topic warrants tons of blog posts, maybe someday…</p>

<p>The next post will focus on Chapter 2, where I’ll delve ever so slightly into Monte Carlo theory and we’ll perform some interesting computations.</p>


    
    <footer><a class="ghost" href="/rendering/2019/02/15/rt_rc_chapter1/">read more »</a></footer>
    
  </article>

  <article>
    <header>
      <h1><a href="/mathematics/2018/07/04/prngs/">Pseudo Random Number Generation</a></h1>
      <time datetime="2018-07-04T10:30:00+02:00">July 4, 2018</time>
    </header>
<p>In this post I’ll talk a bit about pseudo random number generation. This will be the first in an assortment of posts regarding monte carlo methods.</p>

<p>I’ll assume you have working knowledge of calculus and some probability and statistics.</p>

<p>The most essential aspect of any form of monte carlo method is the generation of random numbers. Uniformly distributed random numbers on the interval [0,1] are what we’d like to generate first, as they are also what is required for the other types of distributions.</p>

<p>Generating random numbers using a pseudo random number generator (PRNG) means that we generate a sequence of numbers, using some particular seed value (some arbitrary constant) that initializes the random number generation algorithm. We use the term pseudo, because the numbers generated are not truly random but generated deterministically and hence can be replicated if the same seed and the same constants in the function are used. This is ideal for us, so that we can replicate and debug our algorithms. We can think of these algorithms as generating a deterministic sequence which is based on a starting point.</p>

<p>For this sequence to be considered to be of good quality, it should have certain properties, such as lack of predictibility (i.e. if we generate x values, and we can guess the next, this means the predctibility is possible) and equidistribution. For example if the mean of a large sequence of uniformly distributed numbers in the range [0,1] is not 0.5, then it is likely that something is wrong with the PRNG, given that due to the Law of Large Numbers, we would expect the arithmetic mean of this sequence to be similar to the expected mean (the expected mean being 0.5). We won’t focus on hardcore evaluation PRNGs and leave that to other minds, some useful links are <a href="http://pit-claudel.fr/clement/blog/how-random-is-pseudo-random-testing-pseudo-random-number-generators-and-measuring-randomness/" target="_blank">“How random is pseudorandom testing pseudorandom number generators and measuring randomness”</a> and <a href="http://simul.iro.umontreal.ca/testu01/tu01.html" target="_blank">TestU01 tests</a>. We’ll look at 2 PRNGs and do some simple tests to measure their quality.</p>

<p>Let’s look at a simple PRNG known as the Linear Congruential Generator (which I’ll now continue referring to as LCG).</p>

<p>The LCG is an easy-to-implement PRNG, the function definition being:</p>

<p align="center">
<img src="https://latex.codecogs.com/gif.latex?X_{n&plus;1}=&space;(a&space;*&space;X_n&space;&plus;&space;c)&space;\bmod&space;m" title="X_{n+1}= (a * X_n + c) \bmod m" />
</p>

<p>where:</p>
<ul>
  <li><strong>m</strong> is the modulus constant, and <strong>m</strong> &gt; 0.</li>
  <li><strong>a</strong> is the multiplier, and 0 &lt; <strong>a</strong> &lt; <strong>m</strong>.</li>
  <li><strong>c</strong> is the increment, 0 &lt;= <strong>c</strong> &lt;= <strong>m</strong>.</li>
  <li><strong>X</strong><sub>0</sub> is the seed value, 0 &lt;= <strong>X</strong><sub>0</sub> &lt; <strong>m</strong>.</li>
</ul>

<p>The above constants are all integers. Careful selection of these values ensures that the sequence we get is of a high quality.</p>

<p>Here’s an R listing of what the code for this should look like:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">lcgen</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="m">0</span><span class="o">=</span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">=</span><span class="m">1229</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="o">=</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">=</span><span class="m">2048</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="w">
  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">()</span><span class="w">
  </span><span class="n">x</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="m">0</span><span class="w">
  </span><span class="k">for</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">2</span><span class="o">:</span><span class="p">(</span><span class="n">N</span><span class="m">+1</span><span class="p">))</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="m">-1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">%%</span><span class="w"> </span><span class="n">m</span><span class="w">
  </span><span class="p">}</span><span class="w">
  </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="m">2</span><span class="o">:</span><span class="p">(</span><span class="n">N</span><span class="m">+1</span><span class="p">)]</span><span class="o">/</span><span class="n">m</span><span class="p">)</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>N is the number of random numbers we want to generate. Let’s generate 1000 samples and plot a histogram to look at the distribution.</p>


    
    <footer><a class="ghost" href="/mathematics/2018/07/04/prngs/">read more »</a></footer>
    
  </article>

</main>

<footer>
    <a  class="gray" href="/page2" >« newer posts</a>
    <span class="paginate">page 3 of 4</span>
    <a  class="gray" href="/page4" >older posts »</a>
</footer>



